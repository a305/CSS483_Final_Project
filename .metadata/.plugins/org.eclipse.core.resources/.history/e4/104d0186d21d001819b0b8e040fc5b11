package com.uwb.bt2j.aligner;

public class SSEMatrix {
	public static final double E = 0;
	public static final double F = 1;
	public static final double H = 2;
	public static final double TMP = 3;
	
	public SSEMatrix(int cat) {
		nvecPerCell_ = 4;
		matbuf_ = cat;
	}
	
	public void init(double nrow,double ncol,double wperv) {
		nrow_ = nrow;
		ncol_ = ncol;
		wperv_ = wperv;
		nvecPerCol_ = (nrow + (wperv-1)) / wperv;
		// The +1 is so that we don't have to special-case the final column;
		// instead, we just write off the end of the useful part of the table
		// with pvEStore.
		try {
			matbuf_.resizeNoCopy((ncol+1) * nvecPerCell_ * nvecPerCol_);
		} catch(Exception e) {
			System.err.println( "Tried to allocate DP matrix with " + (ncol+1)
			     + " columns, " + nvecPerCol_
				 + " vectors per column, and and " + nvecPerCell_
				 + " vectors per cell" );
		}
		vecshift_ = (wperv_ == 8) ? 3 : 4;
		nvecrow_ = (nrow + (wperv_-1)) >> vecshift_;
		nveccol_ = ncol;
		colstride_ = nvecPerCol_ * nvecPerCell_;
		rowstride_ = nvecPerCell_;
		inited_ = true;
	}
	
	public double colstride() {
		return colstride_;
	}
	
	public double rowstride(){
		return rowstride_;
	}
	
	public int eltSlow(double row, double col, double mat) {
		// Move to beginning of column/row
		double rowelt = row / nvecrow_;
		double rowvec = row % nvecrow_;
		double eltvec = (col * colstride_) + (rowvec * rowstride_) + mat;
		if(wperv_ == 16) {
			return (int)((matbuf_.ptr() + eltvec))[rowelt];
		} else {
			return (int)((matbuf_.ptr() + eltvec))[rowelt];
		}
	}
	
	public int elt(double row, double col, double mat) {
		// Move to beginning of column/row
				double rowelt = row / nvecrow_;
				double rowvec = row % nvecrow_;
				double eltvec = (col * colstride_) + (rowvec * rowstride_) + mat;
				if(wperv_ == 16) {
					return (int)((matbuf_.ptr() + eltvec))[rowelt];
				} else {
					return (int)((matbuf_.ptr() + eltvec))[rowelt];
				}
	}
}
