package com.uwb.bt2j.inspector;

import java.io.IOException;
import java.io.OutputStream;

import com.uwb.bt2j.util.EList;

class Bowtie2Inspector {
	public static boolean showVersion = false;
	public int verbose = 0;
	public static int names_only = 0;
	public static int summarize_only = 0;
	public static int across = 60;
	public static Boolean refFromEbwt = false;
	public static String wrapper;
	public static final String short_options = "vhnsea:";
	
	public enum ARGS {
		ARG_VERSION(256),
		ARG_WRAPPER(257),
		ARG_USAGE(258);
		
		private int x;
		ARGS(int y){this.x = y;}
	};
	
	public static void printUsage(OutputStream out) {
		out.write(("Bowtie 2 version " + BOWTIE2_VERSION + " by Ben Langmead (langmea@cs.jhu.edu, www.cs.jhu.edu/~langmea)" + "\n"
		+ "Usage: bowtie2-inspect [options]* <bt2_base>" + "\n"
		+ "  <bt2_base>         bt2 filename minus trailing .1." + gEbwt_ext + "/.2." + gEbwt_ext + "\n"
		+ "\n"
		+ "  By default, prints FASTA records of the indexed nucleotide sequences to" + "\n"
		+ "  standard out.  With -n, just prints names.  With -s, just prints a summary of" + "\n"
		+ "  the index parameters and sequences." + "\n"
		+ "\n"
		+ "Options:" + "\n").getBytes());
		if(wrapper == "basic-0") {
			out.write(("  --large-index      force inspection of the 'large' index, even if a" + "\n"
				+ "                     'small' one is present." + "\n").getBytes());
		}
		out.write(("  -a/--across <int>  Number of characters across in FASTA output (default: 60)" + "\n"
		+ "  -n/--names         Print reference sequence names only" + "\n"
		+ "  -s/--summary       Print summary incl. ref names, lengths, index properties" + "\n"
		+ "  -v/--verbose       Verbose output (for debugging)" + "\n"
		+ "  -h/--help          print detailed description of tool and its options" + "\n"
		+ "  --help             print this usage message" + "\n").getBytes());
		;
		if(wrapper.empty()) {
			System.err.print("\n"
			     + "*** Warning ***" + "\n"
				 + "'boowtie2-inspect' was run directly.  It is recommended "
				 + "to use the wrapper script instead."
				 + "\n" + "\n");
		}
	}
	
	public static int parseInt(int lower, String errmsg) {
		long l = Long.parseLong(optarg);

			if (l < lower) {
				System.err.println(errmsg);
				printUsage(System.err);
			}
			return (int)l;

		System.err.println( errmsg);
		printUsage(System.err);
		return -1;
	}
	
	public static void parseOptions(String[] args) {
		int option_index = 0;
		int next_option;
		do {
			next_option = getopt_long(argc, argv, short_options, long_options, &option_index);
			switch (next_option) {
				case ARG_WRAPPER:
					wrapper = optarg;
					break;
				case ARG_USAGE:
				case 'h':
					printUsage(System.out);
					break;
				case 'v': verbose = true; break;
				case ARG_VERSION: showVersion = true; break;
				case 'e': refFromEbwt = true; break;
				case 'n': names_only = true; break;
				case 's': summarize_only = true; break;
				case 'a': across = parseInt(-1, "-a/--across arg must be at least 1"); break;
				case -1: break; /* Done with options. */
				case 0:
					if (long_options[option_index].flag != 0)
						break;
				default:
					printUsage(System.err);
			}
		} while(next_option != -1);
	}
	
	public static void printFastaRecord(OutputStream fout, String defline, String seq) throws IOException {
		fout.write('>');
		fout.write(defline.getBytes());

		if(across > 0) {
			int i = 0;
			while (i + across < seq.length())
			{
				fout.write( seq.substring(i, across).getBytes());
				i += across;
			}
			if (i < seq.length())
				fout.write(seq.substring(i).getBytes());
		} else {
			fout.write(seq.getBytes());
		}
	}
	
	public static void printRefSequence() {
		
	}
	
	public static void printRefSequences() {
		
	}
	
	public static void printIndexSequences() {
		
	}
	
	public static void printIndexSequencesNames() {
		
	}
	
	public static void printIndexSummary() {
		
	}
	
	public static void driver() {
		
	}
	
	public static void main(String[] args){
		try {
			String ebwtFile;  // read serialized Ebwt from this file
			String query;   // read query string(s) from this file
			EList<String> queries;
			String outfile; // write query results to this file
			String argv0 = args[0];
			parseOptions(args);
			if(showVersion) {
				System.out.println( argv0 + " version " + BOWTIE2_VERSION );
				System.out.println( "Built on " + BUILD_HOST);
				System.out.println( BUILD_TIME);
				System.out.println( "Compiler: " + COMPILER_VERSION);
				System.out.println( "Options: " + COMPILER_OPTIONS);
			}

			// Get input filename
			if(optind >= args.length) {
				System.err.println("No index name given!");
				printUsage(System.err);
			}
			ebwtFile = args[optind++];

			// Optionally summarize
			if(verbose) {
				System.out.println( "Input ebwt file: \"" + ebwtFile + "\"");
				System.out.println( "Output file: \"" + outfile + "\"");
				System.out.println( "Local endianness: " + (currentlyBigEndian()? "big":"little"));
			}
			driver(ebwtFile, query);
		} catch(Exception e) {
			System.err.println("Error: Encountered exception: '" + e + "'");
			System.err.print("Command: ");
			for(int i = 0; i < args.length; i++) System.err.print(args[i] + " ");
			System.err.println();
		}
	}
}