package com.uwb.bt2j.aligner;

import com.uwb.bt2j.util.strings.BTDnaString;
import com.uwb.bt2j.util.strings.BTString;

public class SwAligner {
	public void initRead(
			BTDnaString rdfw, // forward read sequence
			BTDnaString rdrc, // revcomp read sequence
			BTString qufw,    // forward read qualities
			BTString qurc,    // reverse read qualities
			double rdi,              // offset of first read char to align
			double rdf,              // offset of last read char to align
			Scoring sc)       // scoring scheme
	{
		int nceil = sc.nCeil.f<Integer>((double)rdfw.length());
		rdfw_    = rdfw;      // read sequence
		rdrc_    = rdrc;      // read sequence
		qufw_    = qufw;      // read qualities
		qurc_    = qurc;      // read qualities
		rdi_     = rdi;        // offset of first read char to align
		rdf_     = rdf;        // offset of last read char to align
		sc_      = sc;        // scoring scheme
		nceil_   = nceil;      // max # Ns allowed in ref portion of aln
		readSse16_ = false;    // true -> sse16 from now on for this read
		initedRead_ = true;

		if(dpLog_ != null) {
			if(!firstRead_) {
				dpLog_.write('\n');
			}
			dpLog_.write(rdfw.toZBuf() + '\t' + qufw.toZBuf());
		}
		firstRead_ = false;
	}
	
	public void initRef(
			Boolean fw,               // whether to forward or revcomp read is aligning
			TRefId refidx,         // id of reference aligned against
			const DPRect rect,    // DP rectangle
			char rf,              // reference sequence
			size_t rfi,            // offset of first reference char to align to
			size_t rff,            // offset of last reference char to align to
			TRefOff reflen,        // length of reference sequence
			const Scoring sc,     // scoring scheme
			TAlScore minsc,        // minimum score
			Boolean enable8,          // use 8-bit SSE if possible?
			size_t cminlen,        // minimum length for using checkpointing scheme
			size_t cpow2,          // interval b/t checkpointed diags; 1 << this
			Boolean doTri,            // triangular mini-fills?
			Boolean extend)           // is this a seed extension?
			{
		size_t readGaps = sc.maxReadGaps(minsc, rdfw_->length());
		size_t refGaps  = sc.maxRefGaps(minsc, rdfw_->length());
		assert_geq(readGaps, 0);
		assert_geq(refGaps, 0);
		assert_gt(rff, rfi);
		rdgap_       = readGaps;  // max # gaps in read
		rfgap_       = refGaps;   // max # gaps in reference
		state_       = STATE_INITED;
		fw_          = fw;       // orientation
		rd_          = fw ? rdfw_ : rdrc_; // read sequence
		qu_          = fw ? qufw_ : qurc_; // quality sequence
		refidx_      = refidx;   // id of reference aligned against
		rf_          = rf;       // reference sequence
		rfi_         = rfi;      // offset of first reference char to align to
		rff_         = rff;      // offset of last reference char to align to
		reflen_      = reflen;   // length of entire reference sequence
		rect_        = &rect;    // DP rectangle
		minsc_       = minsc;    // minimum score
		cural_       = 0;        // idx of next alignment to give out
		initedRef_   = true;     // indicate we've initialized the ref portion
		enable8_     = enable8;  // use 8-bit SSE if possible?
		extend_      = extend;   // true iff this is a seed extension
		cperMinlen_  = cminlen;  // reads shorter than this won't use checkpointer
		cperPerPow2_ = cpow2;    // interval b/t checkpointed diags; 1 << this
		cperEf_      = true;     // whether to checkpoint H, E, and F
		cperTri_     = doTri;    // triangular mini-fills?
		bter_.initRef(
			fw_ ? rdfw_->buf() : // in: read sequence
				  rdrc_->buf(), 
			fw_ ? qufw_->buf() : // in: quality sequence
				  qurc_->buf(),
			rd_->length(),       // in: read sequence length
			rf_ + rfi_,          // in: reference sequence
			rff_ - rfi_,         // in: in-rectangle reference sequence length
			reflen,              // in: total reference sequence length
			refidx_,             // in: reference id
			rfi_,                // in: reference offset
			fw_,                 // in: orientation
			rect_,               // in: DP rectangle
			&cper_,              // in: checkpointer
			*sc_,                // in: scoring scheme
			nceil_);             // in: N ceiling
		// Record the reference sequence in the log
		if(dpLog_ != NULL) {
			(*dpLog_) << '\t';
			(*dpLog_) << refidx_ << ',';
			(*dpLog_) << reflen_ << ',';
			(*dpLog_) << minsc_ << ',';
			(*dpLog_) << (fw ? '+' : '-') << ',';
			rect_->write(*dpLog_);
			(*dpLog_) << ',';
			for(TRefOff i = rfi_; i < rff_; i++) {
				(*dpLog_) << mask2dna[(int)rf[i]];
			}
		}
	}
	
	public void initRef(
			bool fw,               // whether to forward or revcomp read is aligning
			TRefId refidx,         // reference aligned against
			const DPRect rect,    // DP rectangle
			const BitPairReference refs, // Reference strings
			TRefOff reflen,        // length of reference sequence
			const Scoring sc,     // scoring scheme
			TAlScore minsc,        // minimum score
			bool enable8,          // use 8-bit SSE if possible?
			size_t cminlen,        // minimum length for using checkpointing scheme
			size_t cpow2,          // interval b/t checkpointed diags; 1 << this
			bool doTri,            // triangular mini-fills?
			bool extend,           // true iff this is a seed extension
			size_t  upto,          // count the number of Ns up to this offset
			size_t& nsUpto)        // output: the number of Ns up to 'upto'
			{
		TRefOff rfi = rect.refl;
		TRefOff rff = rect.refr + 1;
		assert_gt(rff, rfi);
		// Capture an extra reference character outside the rectangle so that we
		// can check matches in the next column over to the right
		rff++;
		// rflen = full length of the reference substring to consider, including
		// overhang off the boundaries of the reference sequence
		const size_t rflen = (size_t)(rff - rfi);
		// Figure the number of Ns we're going to add to either side
		size_t leftNs  =
			(rfi >= 0               ? 0 : (size_t)std::abs(static_cast<long>(rfi)));
		leftNs = min(leftNs, rflen);
		size_t rightNs =
			(rff <= (TRefOff)reflen ? 0 : (size_t)std::abs(static_cast<long>(rff - reflen)));
		rightNs = min(rightNs, rflen);
		// rflenInner = length of just the portion that doesn't overhang ref ends
		assert_geq(rflen, leftNs + rightNs);
		const size_t rflenInner = rflen - (leftNs + rightNs);
	#ifndef NDEBUG
		bool haveRfbuf2 = false;
		EList<char> rfbuf2(rflen);
		// This is really slow, so only do it some of the time
		if((rand() % 10) == 0) {
			TRefOff rfii = rfi;
			for(size_t i = 0; i < rflen; i++) {
				if(rfii < 0 || (TRefOff)rfii >= reflen) {
					rfbuf2.push_back(4);
				} else {
					rfbuf2.push_back(refs.getBase(refidx, (size_t)rfii));
				}
				rfii++;
			}
			haveRfbuf2 = true;
		}
	#endif
		// rfbuf_ = uint32_t list large enough to accommodate both the reference
		// sequence and any Ns we might add to either side.
		rfwbuf_.resize((rflen + 16) / 4);
		int offset = refs.getStretch(
			rfwbuf_.ptr(),               // buffer to store words in
			refidx,                      // which reference
			(rfi < 0) ? 0 : (size_t)rfi, // starting offset (can't be < 0)
			rflenInner                   // length to grab (exclude overhang)
			ASSERT_ONLY(, tmp_destU32_));// for BitPairReference::getStretch()
		assert_leq(offset, 16);
		rf_ = (char*)rfwbuf_.ptr() + offset;
		// Shift ref chars away from 0 so we can stick Ns at the beginning
		if(leftNs > 0) {
			// Slide everyone down
			for(size_t i = rflenInner; i > 0; i--) {
				rf_[i+leftNs-1] = rf_[i-1];
			}
			// Add Ns
			for(size_t i = 0; i < leftNs; i++) {
				rf_[i] = 4;
			}
		}
		if(rightNs > 0) {
			// Add Ns to the end
			for(size_t i = 0; i < rightNs; i++) {
				rf_[i + leftNs + rflenInner] = 4;
			}
		}
	#ifndef NDEBUG
		// Sanity check reference characters
		for(size_t i = 0; i < rflen; i++) {
			assert(!haveRfbuf2 || rf_[i] == rfbuf2[i]);
			assert_range(0, 4, (int)rf_[i]);
		}
	#endif
		// Count Ns and convert reference characters into A/C/G/T masks.  Ambiguous
		// nucleotides (IUPAC codes) have more than one mask bit set.  If a
		// reference scanner was provided, use it to opportunistically resolve seed
		// hits.
		nsUpto = 0;
		for(size_t i = 0; i < rflen; i++) {
			// rf_[i] gets mask version of refence char, with N=16
			if(i < upto && rf_[i] > 3) {
				nsUpto++;
			}
			rf_[i] = (1 << rf_[i]);
		}
		// Correct for having captured an extra reference character
		rff--;
		initRef(
			fw,          // whether to forward or revcomp read is aligning
			refidx,      // id of reference aligned against
			rect,        // DP rectangle
			rf_,         // reference sequence, wrapped up in BTString object
			0,           // use the whole thing
			(size_t)(rff - rfi), // ditto
			reflen,      // reference length
			sc,          // scoring scheme
			minsc,       // minimum score
			enable8,     // use 8-bit SSE if possible?
			cminlen,     // minimum length for using checkpointing scheme
			cpow2,       // interval b/t checkpointed diags; 1 << this
			doTri,       // triangular mini-fills?
			extend);     // true iff this is a seed extension
	}
	
	public ungappedAlign(
			const BTDnaString&      rd,     // read sequence (could be RC)
			const BTString&         qu,     // qual sequence (could be rev)
			const Coord&            coord,  // coordinate aligned to
			const BitPairReference& refs,   // Reference strings
			size_t                  reflen, // length of reference sequence
			const Scoring&          sc,     // scoring scheme
			bool                    ohang,  // allow overhang?
			TAlScore                minsc,  // minimum score
			SwResult&               res)    // put alignment result here
	{
		
	}
}
