package com.uwb.bt2j.aligner;
class BtBranch {

  protected double parentId_;
  protected double penalty_;
  protected double score_st_;
  protected double score_en_;
  protected double len_;
  protected long row_;
  protected long col_;
  protected Edit e_;
  
  protected Boolean root_;
  protected Boolean curtailed_;
  
  public enum BTStatus {
	  BT_NOT_FOUND(1),      // could not obtain the backtrace because it
              // overlapped a previous solution
	  BT_FOUND(2),              // obtained a valid backtrace
	  BT_REJECTED_N(3),         // backtrace rejected because it had too many Ns
	  BT_REJECTED_CORE_DIAG(4);  // backtrace rejected because it failed to overlap a
              // core diagonal
	  private int x;
	  BTStatus(int y){x = y;}
  }
  
  public BtBranch() {
	  reset();
  }
  
  public BtBranch(
		  const BtBranchProblem& prob,
			size_t parentId,
			TAlScore penalty,
			TAlScore score_en,
			int64_t row,
			int64_t col,
			Edit e,
			int hef,
			bool root,
			bool extend){
	  init(prob, parentId, penalty, score_en, row, col, e, hef, root, extend);
  }
  
  public void reset() {
	  	parentId_ = 0;
		score_st_ = score_en_ = len_ = row_ = col_ = 0;
		curtailed_ = false;
		e_.reset();
  }
  
  public void init(
		  const BtBranchProblem& prob,
			size_t parentId,
			TAlScore penalty,
			TAlScore score_en,
			int64_t row,
			int64_t col,
			Edit e,
			int hef,
			bool root,
			bool extend)
  {
    
  }
  
  public Boolean isSolution(BtBranchProblem prob) {
	  	const bool end2end = prob.sc_->monotone;
		return score_st_ == prob.targ_ && (!end2end || endsInFirstRow());
  }
  
  public Boolean isValid() {
    
  }
  
  public Boolean overlap() {
  
  }
  
  public Boolean endsInFirstRow() {
    
  }
  
  public double uppermostRow() {
    
  }
  
  public Boolean leftmostCol() {
    
  }
}
