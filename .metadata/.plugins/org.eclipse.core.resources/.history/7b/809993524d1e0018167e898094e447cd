package com.uwb.bt2j.util.pattern;

import com.uwb.bt2j.aligner.Read;
import com.uwb.bt2j.util.EList;
import com.uwb.bt2j.util.file.FileBuf;

import javafx.util.Pair;

public class FastaPatternSource extends CFilePatternSource {
	protected boolean first_;
	
	public FastaPatternSource(PatternParams p, EList<String> infiles) {
		super(p, infiles);
		first_ = true;
	}
	
	public abstract boolean parse(Read ra, Read rb, long rdid);

	@Override
	protected Pair<Boolean, Integer> nextBatchFromFile(PerThreadReadBuf pt, boolean batch_a, int read_idx) {
		int c;
		EList<Read> readbuf = batch_a ? pt.bufa_ : pt.bufb_;
		if(first_) {
			c = getc_wrapper();
			if (c == -1) {
				return new Pair(true, 0);
			}
			while(c == '\r' || c == '\n') {
				c = getc_wrapper();
			}
			if(c != '>') {
				System.err.println("Error: reads file does not look like a FASTA file");
			}
			first_ = false;
		}
		boolean done = false;
		// Read until we run out of input or until we've filled the buffer
		for(; readi < pt.max_buf_ && !done; readi++) {
			Read::TBuf& buf = readbuf[readi].readOrigBuf;
			buf.clear();
			buf.append('>');
			while(true) {
				c = getc_wrapper();
				if(c < 0 || c == '>') {
					done = c < 0;
					break;
				}
				buf.append(c);
			}
		}
		// Immediate EOF case
		if(done && readbuf[readi-1].readOrigBuf.length() == 1) {
			readi--;
		}
		return make_pair(done, readi);
	}

	@Override
	protected void resetForNextFile() {
		first_ = true;
	}

	@Override
	public void nextBatch(PerThreadReadBuf pt, boolean batch_a, boolean lock) {
		// TODO Auto-generated method stub
		
	}
	
	protected static int skipToNextFastaRecord(FileBuf in) {
		int c;
		while((c = in.get()) != '>') {
			if(in.eof()) return -1;
		}
		return c;
	}
	
	
	public void reset() {
		first_ = true;
		super.reset();
	}
}
