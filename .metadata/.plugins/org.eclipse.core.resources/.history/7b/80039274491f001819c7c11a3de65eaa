package com.uwb.bt2j.aligner.sink;

import com.uwb.bt2j.aligner.Read;

public class AlnSinkWrap {
	protected AlnSink g_;
	protected ReportingParams rp_;
	protected double threadid_;
	protected Mapq mapq_;
	protected boolean init_;
	protected boolean maxed1_;
	protected boolean maxed2_;
	protected boolean maxedOverall_;
	protected long bestPair_;
	protected long best2Pair_;
	protected long bestUnp1;
	protected long best2Unp1;
	protected long bestUnp2;
	protected long best2Unp2;
	protected final Read rd1_;
	protected final Read rd2_;
	protected double rdid_;
	protected EList<AlnRes> rs1_;
	protected EList<AlnRes> rs2_;
	protected EList<AlnRes> rs1u_;
	protected EList<AlnRes> rs2u_;
	protected EList<double> select1_;
	protected EList<double> select2_;
	protected ReportingState st_;
	protected EList<Pair<AlnScore, double>> selectBuf_;
	protected BString obuf_;
	protected StackedAln staln_;

	public int nextRead() {
		
	}
	
	public void finishRead() {
		
	}
	
	public boolean report() {
		
	}
	
	public final boolean empty() {
		return rs1_.empty() && rs1u_.empty() && rs2u_.empty();
	}
	
	public final boolean maxed() {
		return maxedOverall_;
	}
	
	public final boolean readIsPair() {
		return rd1_ != null && rd2_ != null;
	}
	
	public final boolean inited() {
		return init_;
	}
	
	public final ReportingState state() {
		return st_;
	}
	
	public final boolean Mmode() {
		return rp_.mhitsSet();
	}
	
	public final boolean allHits() {
		return rp_.allHits();
	}
	
	public final boolean hasSecondBestUnp1() {
		return best2Unp1_ != Long.MIN_VALUE;
	}
	
	public final boolean hasSecondBestUnp2() {
		return best2Unp2_ != Long.MIN_VALUE;
	}
	
	public final boolean hasSecondBestPair() {
		return best2Pair_ != Long.MIN_VALUE;
	}
	
	public final long bestUnp1() {
		return bestUnp1_;
	}
	
	public final long secondBestUnp1() {
		return best2Unp1;
	}
	
	public final long bestUnp2() {
		return bestUnp2_;
	}
	
	public final long secondBestUnp2() {
		return best2Unp2;
	}
	
	public final long bestPair() {
		return bestPair_;
	}
	
	public final long secondBestPar() {
		return best2Pair;
	}
	
	public boolean sameRead(
			Read rd1,      // new mate #1
			Read rd2,      // new mate #2
			boolean qualitiesMatter) // aln policy distinguishes b/t quals?{
	boolean same = false;
	if(rd1_ != null || rd2_ != null) {
		// This is not the first time the sink was initialized with
		// a read.  Check if new read/pair is identical to previous
		// read/pair
		if((rd1_ == null) == (rd1 == null) &&
		   (rd2_ == null) == (rd2 == null))
		{
			boolean m1same = (rd1 == null && rd1_ == null);
			if(!m1same) {
				assert(rd1 != null);
				assert(rd1_ != null);
				m1same = Read.same(
					rd1.patFw,  // new seq
					rd1.qual,   // new quals
					rd1_.patFw, // old seq
					rd1_.qual,  // old quals
					qualitiesMatter);
			}
			if(m1same) {
				boolean m2same = (rd2 == null && rd2_ == null);
				if(!m2same) {
					m2same = Read.same(
						rd2.patFw,  // new seq
						rd2.qual,   // new quals
						rd2_.patFw, // old seq
						rd2_.qual,  // old quals
						qualitiesMatter);
				}
				same = m2same;
			}
		}
	}
	return same;
	}
	
	protected boolean prepareDiscordants() {
		
	}
	
	protected final double selectAlnsToReport(final EList<AlnRes> rs, long num, EList<double> select, RandomSource rnd) {
		
	}
	
	protected final double selectByScore() {
		
	}
	
	
}
