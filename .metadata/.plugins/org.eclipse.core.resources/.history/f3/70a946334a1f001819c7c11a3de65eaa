package com.uwb.bt2j.aligner.sink;

import com.uwb.bt2j.aligner.PerReadMetrics;
import com.uwb.bt2j.aligner.RandomSource;
import com.uwb.bt2j.aligner.Read;
import com.uwb.bt2j.aligner.Scoring;
import com.uwb.bt2j.aligner.seed.SeedResults;

public class AlnSinkWrap {
	protected AlnSink g_;
	protected ReportingParams rp_;
	protected double threadid_;
	protected Mapq mapq_;
	protected boolean init_;
	protected boolean maxed1_;
	protected boolean maxed2_;
	protected boolean maxedOverall_;
	protected long bestPair_;
	protected long best2Pair_;
	protected long bestUnp1;
	protected long best2Unp1;
	protected long bestUnp2;
	protected long best2Unp2;
	protected final Read rd1_;
	protected final Read rd2_;
	protected double rdid_;
	protected EList<AlnRes> rs1_;
	protected EList<AlnRes> rs2_;
	protected EList<AlnRes> rs1u_;
	protected EList<AlnRes> rs2u_;
	protected EList<double> select1_;
	protected EList<double> select2_;
	protected ReportingState st_;
	protected EList<Pair<AlnScore, double>> selectBuf_;
	protected BString obuf_;
	protected StackedAln staln_;

	public int nextRead(
			Read rd1,      // new mate #1
			Read rd2,      // new mate #2
			long rdid,         // read ID for new pair
			boolean qualitiesMatter) // aln policy distinguishes b/t quals?
	{
		init_ = true;
		// Keep copy of new read, so that we can compare it with the
		// next one
		if(rd1 != null) {
			rd1_ = rd1;
		} else rd1_ = null;
		if(rd2 != null) {
			rd2_ = rd2;
		} else rd2_ = null;
		rdid_ = rdid;
		// Caller must now align the read
		maxed1_ = false;
		maxed2_ = false;
		maxedOverall_ = false;
		bestPair_ = best2Pair_ =
		bestUnp1_ = best2Unp1_ =
		bestUnp2_ = best2Unp2_ = Long.MIN_VALUE;
		rs1_.clear();     // clear out paired-end alignments
		rs2_.clear();     // clear out paired-end alignments
		rs1u_.clear();    // clear out unpaired alignments for mate #1
		rs2u_.clear();    // clear out unpaired alignments for mate #2
		st_.nextRead(readIsPair()); // reset state
		// Start from the first stage
		return 0;
	}
	
	public void finishRead(
			SeedResults sr1,         // seed alignment results for mate 1
			SeedResults sr2,         // seed alignment results for mate 2
			boolean               exhaust1,    // mate 1 exhausted?
			boolean               exhaust2,    // mate 2 exhausted?
			boolean               nfilt1,      // mate 1 N-filtered?
			boolean               nfilt2,      // mate 2 N-filtered?
			boolean               scfilt1,     // mate 1 score-filtered?
			boolean               scfilt2,     // mate 2 score-filtered?
			boolean               lenfilt1,    // mate 1 length-filtered?
			boolean               lenfilt2,    // mate 2 length-filtered?
			boolean               qcfilt1,     // mate 1 qc-filtered?
			boolean               qcfilt2,     // mate 2 qc-filtered?
			RandomSource      rnd,         // pseudo-random generator
			ReportingMetrics  met,         // reporting metrics
			PerReadMetrics prm,      // per-read metrics
			Scoring sc,              // scoring scheme
			boolean suppressSeedSummary,       // = true
			boolean suppressAlignments,        // = false
			boolean scUnMapped,                // = false
			boolean xeq)                       // = false
	{
		
	}
	
	public boolean report() {
		
	}
	
	public final boolean empty() {
		return rs1_.empty() && rs1u_.empty() && rs2u_.empty();
	}
	
	public final boolean maxed() {
		return maxedOverall_;
	}
	
	public final boolean readIsPair() {
		return rd1_ != null && rd2_ != null;
	}
	
	public final boolean inited() {
		return init_;
	}
	
	public final ReportingState state() {
		return st_;
	}
	
	public final boolean Mmode() {
		return rp_.mhitsSet();
	}
	
	public final boolean allHits() {
		return rp_.allHits();
	}
	
	public final boolean hasSecondBestUnp1() {
		return best2Unp1_ != Long.MIN_VALUE;
	}
	
	public final boolean hasSecondBestUnp2() {
		return best2Unp2_ != Long.MIN_VALUE;
	}
	
	public final boolean hasSecondBestPair() {
		return best2Pair_ != Long.MIN_VALUE;
	}
	
	public final long bestUnp1() {
		return bestUnp1_;
	}
	
	public final long secondBestUnp1() {
		return best2Unp1;
	}
	
	public final long bestUnp2() {
		return bestUnp2_;
	}
	
	public final long secondBestUnp2() {
		return best2Unp2;
	}
	
	public final long bestPair() {
		return bestPair_;
	}
	
	public final long secondBestPar() {
		return best2Pair;
	}
	
	public boolean sameRead(
			Read rd1,      // new mate #1
			Read rd2,      // new mate #2
			boolean qualitiesMatter) {// aln policy distinguishes b/t quals?{
	boolean same = false;
	if(rd1_ != null || rd2_ != null) {
		// This is not the first time the sink was initialized with
		// a read.  Check if new read/pair is identical to previous
		// read/pair
		if((rd1_ == null) == (rd1 == null) &&
		   (rd2_ == null) == (rd2 == null))
		{
			boolean m1same = (rd1 == null && rd1_ == null);
			if(!m1same) {
				assert(rd1 != null);
				assert(rd1_ != null);
				m1same = Read.same(
					rd1.patFw,  // new seq
					rd1.qual,   // new quals
					rd1_.patFw, // old seq
					rd1_.qual,  // old quals
					qualitiesMatter);
			}
			if(m1same) {
				boolean m2same = (rd2 == null && rd2_ == null);
				if(!m2same) {
					m2same = Read.same(
						rd2.patFw,  // new seq
						rd2.qual,   // new quals
						rd2_.patFw, // old seq
						rd2_.qual,  // old quals
						qualitiesMatter);
				}
				same = m2same;
			}
		}
	}
	return same;
	}
	
	protected boolean prepareDiscordants() {
		
	}
	
	protected final double selectAlnsToReport(final EList<AlnRes> rs, long num, EList<double> select, RandomSource rnd) {
		
	}
	
	protected final double selectByScore() {
		
	}
	
	
}
