package com.uwb.bt2j.util.types;

public class RedBlack <K, P>{
	public RedBlack(int pageSz, int cat) {
		//perPage_ = pageSz/
		pages_ = cat;
		clear();
	}
	
	public RedBlackNode lookup(K key) {
		RedBlackNode cur = root_;
		while(cur != null) {
			if(cur == key) return cur;
			if(cur < key) {
				cur = cur.right;
			} else {
				cur = cur.left;
			}
		}
		return null;
	}
	
	public RedBlackNode add(Pool p, K key, boolean added) {
		// Look for key; if it's not there, get its parent
				RedBlackNode cur = root_;
				RedBlackNode parent = null;
				boolean leftChild = true;
				while(cur != null) {
					if(cur == key) {
						// Found it; break out of loop with cur != NULL
						break;
					}
					parent = cur;
					if((*cur) < key) {
						if((cur = cur->right) == NULL) {
							// Fell off the bottom of the tree as the right
							// child of parent 'lastCur'
							leftChild = false;
						}
					} else {
						if((cur = cur->left) == NULL) {
							// Fell off the bottom of the tree as the left
							// child of parent 'lastCur'
							leftChild = true;
						}
					}
				}
				if(cur != NULL) {
					// Found an entry; assert if we weren't supposed to
					if(added != NULL) *added = false;
				} else {
					assert(root_ == NULL || !root_->red);
					if(!addNode(p, cur)) {
						// Exhausted memory
						return NULL;
					}
					assert(cur != NULL);
					assert(cur != root_);
					assert(cur != parent);
					// Initialize new node
					cur->key = key;
					cur->left = cur->right = NULL;
					cur->red = true; // red until proven black
					keys_++;
					if(added != NULL) *added = true;
					// Put it where we know it should go
					addNode(cur, parent, leftChild);
				}
				return cur; // return the added or found node
	}
}
