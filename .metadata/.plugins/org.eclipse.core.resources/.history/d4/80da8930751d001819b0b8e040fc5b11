package com.uwb.bt2j.aligner;

public class SAMConfig<T, TStr> {
	
	protected Boolean truncQname_;   // truncate QNAME to 255 chars?
	protected Boolean omitsec_;      // omit secondary 
	protected Boolean noUnal_;       // omit unaligned reads
	
	protected String pg_id_; // @PG ID: Program record identifier
	protected String pg_pn_; // @PG PN: Program name
	protected String pg_vn_; // @PG VN: Program version
	protected String pg_cl_; // @PG CL: Program command-line
	protected String rgs_;   // Read-group string to add to all records
	EList<String> refnames_; // reference sequence names
	EList<double> reflens_;  // reference sequence lengths
	
	// Which alignment flags to print?

	// Following are printed by BWA-SW
	protected Boolean print_as_; // AS:i: Alignment score generated by aligner
	protected Boolean print_xs_; // XS:i: Suboptimal alignment score
	protected Boolean print_xss_;// Xs:i: Best invalid alignment score found
	protected Boolean print_yn_; // YN:i:, Yn:i: minimum valid score and perfect score
	protected Boolean print_xn_; // XN:i: Number of ambiguous bases in the referenece

	// Following are printed by BWA
	protected Boolean print_x0_; // X0:i: Number of best hits
	protected Boolean print_x1_; // X1:i: Number of sub-optimal best hits
	protected Boolean print_xm_; // XM:i: Number of mismatches in the alignment
	protected Boolean print_xo_; // XO:i: Number of gap opens
	protected Boolean print_xg_; // XG:i: Number of gap extensions (incl. opens)
	protected Boolean print_nm_; // NM:i: Edit dist. to the ref, Ns count, clipping doesn't
	protected Boolean print_md_; // MD:Z: String for mms. [0-9]+(([A-Z]|\^[A-Z]+)[0-9]+)*2

	// Following are Bowtie2-specific
	protected Boolean print_yf_; // YF:i: Read was filtered out?
	protected Boolean print_yi_; // YI:Z: Summary of inputs to MAPQ calculation
	protected Boolean print_ym_; // YM:i: Read was repetitive when aligned unpaired?
	protected Boolean print_yp_; // YP:i: Read was repetitive when aligned paired?
	protected Boolean print_yt_; // YT:Z: String representing alignment type
	protected Boolean print_ys_; // YS:i: Score of other mate
	protected Boolean print_zs_; // ZS:i: Pseudo-random seed
	
	protected Boolean print_xr_; // XR:Z: Original read string
	protected Boolean print_xt_; // XT:i: Time taken to align
	protected Boolean print_xd_; // XD:i: DP problems
	protected Boolean print_xu_; // XU:i: ungapped alignment
	protected Boolean print_ye_; // YE:i: streak of failed DPs at end
	protected Boolean print_yl_; // YL:i: longest streak of failed DPs
	protected Boolean print_yu_; // YU:i: index of last succeeded DP
	protected Boolean print_xp_; // XP:BI: seed hit information
	protected Boolean print_yr_; // YR:i: # redundant seed hits
	protected Boolean print_zb_; // ZB:i: # Ftab lookups
	protected Boolean print_zr_; // ZR:i: # redundant path checks
	protected Boolean print_zf_; // ZF:i: # FM Index ops
	protected Boolean print_zm_; // ZM:i: FM ops string for best-first search
	protected Boolean print_zi_; // ZI:i: # extend loop iters
	protected Boolean print_zp_; // ZP:i: Score of best/second-best paired-end alignment
	protected Boolean print_zu_; // ZU:i: Score of best/second-best unpaired alignment
	protected Boolean print_zt_; // ZT:Z: Extra features for MAPQ estimation
	
	public enum SamFlags {
		// Comments use language from v1.4-r962 spec
		SAM_FLAG_PAIRED(1),   // templ. having mult. frag.s in sequencing
		SAM_FLAG_MAPPED_PAIRED(2),   // each frag properly aligned
		SAM_FLAG_UNMAPPED(4),   // fragment unmapped
		SAM_FLAG_MATE_UNMAPPED(8),   // next fragment in template unmapped
		SAM_FLAG_QUERY_STRAND(16),  // SEQ is reverse comp'ed from original
		SAM_FLAG_MATE_STRAND(32),  // next fragment SEQ reverse comp'ed
		SAM_FLAG_FIRST_IN_PAIR(64),  // first fragment in template
		SAM_FLAG_SECOND_IN_PAIR(128), // last fragment in template
		SAM_FLAG_NOT_PRIMARY(256), // secondary alignment
		SAM_FLAG_FAILS_CHECKS(512), // not passing quality controls
		SAM_FLAG_DUPLICATE(1024); // PCR or optical duplicate
		private int x;
		SamFlags(int y){x = y;}
	}
	public SamConfig(
			EList<String> refnames,  // reference sequence names
			EList<double> reflens,   // reference sequence lengths
			Boolean truncQname,          // truncate read name to 255?
			Boolean omitsec,             // omit secondary SEQ/QUAL
			Boolean noUnal,              // omit unaligned reads
			String pg_id, // id
			String pg_pn, // name
			String pg_vn, // version
			String pg_cl, // command-line
			String rgs,   // read groups string
			Boolean print_as,
			Boolean print_xs,
			Boolean print_xss,
			Boolean print_yn,
			Boolean print_xn,
			Boolean print_x0,
			Boolean print_x1,
			Boolean print_xm,
			Boolean print_xo,
			Boolean print_xg,
			Boolean print_nm,
			Boolean print_md,
			Boolean print_yf,
			Boolean print_yi,
			Boolean print_ym,
			Boolean print_yp,
			Boolean print_yt,
			Boolean print_ys,
			Boolean print_zs,
			Boolean print_xr,
			Boolean print_xt,
			Boolean print_xd,
			Boolean print_xu,
			Boolean print_ye, // streak of failed DPs at end
			Boolean print_yl, // longest streak of failed DPs
			Boolean print_yu, // index of last succeeded DP
			Boolean print_xp, // print seed hit information
			Boolean print_yr, // # redundant seed hits
			Boolean print_zb, // # Ftab lookups
			Boolean print_zr, // # redundant path checks
			Boolean print_zf, // # FM Index ops
			Boolean print_zm, // FM Index op string for best-first search
			Boolean print_zi, // # seed extend loop iters
			Boolean print_zp,
			Boolean print_zu,
			Boolean print_zt) {
		truncQname_ = truncQname;
		omitsec_ = omitsec;
		noUnal_ = noUnal;
		pg_id_ = pg_id;
		pg_pn_=pg_pn;
		pg_vn_=pg_vn;
		pg_cl_=pg_cl;
		rgs_=rgs;
		refnames_=refnames;
		reflens_=reflens;
		print_as_=print_as; // alignment score of best alignment
		print_xs_=print_xs; // alignment score of second-best alignment
		print_xss_=print_xss;
		print_yn_=print_yn; // minimum valid score and perfect score
		print_xn_=print_xn;
		print_x0_=print_x0;
		print_x1_=print_x1;
		print_xm_=print_xm;
		print_xo_=print_xo;
		print_xg_=print_xg;
		print_nm_=print_nm;
		print_md_=print_md;
		print_yf_=print_yf;
		print_yi_=print_yi;
		print_ym_=print_ym;
		print_yp_=print_yp;
		print_yt_=print_yt;
		print_ys_=print_ys;
		print_zs_=print_zs;
		print_xr_=print_xr;
		print_xt_=print_xt; // time elapsed in microseconds
		print_xd_=print_xd; // DP extend attempts
		print_xu_=print_xu; // ungapped extend attempts
		print_ye_=print_ye; // streak of failed DPs at end
		print_yl_=print_yl; // longest streak of failed DPs
		print_yu_=print_yu; // index of last succeeded DP
		print_xp_=print_xp; // print seed hit information
		print_yr_=print_yr; // index of last succeeded DP
		print_zb_=print_zb; // # Ftab lookups
		print_zr_=print_zr; // # redundant path checks
		print_zf_=print_zf; // # FM Index ops
		print_zm_=print_zm; // FM Index op string for best-first search
		print_zi_=print_zi; // # seed extend loop iters
		print_zp_=print_zp; // # seed extend loop iters
		print_zu_=print_zu; // # seed extend loop iters
		print_zt_=print_zt;  // extra features for MAPQ estimation
	}
	
	public void printRefNameFromIndex(BTString o, size_t i) {
		printRefName(o, refnames_[i]);
	}
	
	public void printRefName(BTString o, String name) {
		size_t namelen = name.length();
		for(size_t i = 0; i < namelen; i++) {
			if(isspace(name[i])) {
				return;
			}
			o.append(name[i]);
		}
	}
	
	public void printOptFieldEscapedZ(BTString o, T s) {
		double len = s.length();
		for(double i = 0; i < len; i++) {
			if(s[i] < 33 || s[i] > 126 || s[i] == ':' || s[i] == '%') {
				// percent-encode it
				o.append('%');
				int ms = s[i] >> 4;
				int ls = s[i] & 15;
				o.append("0123456789ABCDEF"[ms]);
				o.append("0123456789ABCDEF"[ls]);
			} else {
				o.append(s[i]);
			}
		}
	}
	
	public void printOptFieldNewlineEscapedZ(BTString o, T s) {
		double len = s.length();
		for(double i = 0; i < len; i++) {
			if(s[i] == 10 || s[i] == 13 || s[i] == '%') {
				// percent-encode it
				o.append('%');
				int ms = s[i] >> 4;
				int ls = s[i] & 15;
				o.append("0123456789ABCDEF"[ms]);
				o.append("0123456789ABCDEF"[ls]);
			} else {
				o.append(s[i]);
			}
		}
	}
	
	public void printReadName(
			BTString o,
			TStr name,
			Boolean omitSlashMate)
		{
			double namelen = name.length();
			if(omitSlashMate &&
			   namelen >= 2 &&
			   name[namelen-2] == '/' &&
			   (name[namelen-1] == '1' || name[namelen-1] == '2' || name[namelen-1] == '3'))
			{
				namelen -= 2;
			}
			if(truncQname_ && namelen > 255) {
				namelen = 255;
			}
			for(double i = 0; i < namelen; i++) {
				if(truncQname_ && isspace(name[i])) {
					return;
				}
				o.append(name[i]);
			}
		}
	
	public void printRefNameFromIndex(
			BTString o,
			double i) {
		
	}
	
	public void printHeader(BTString o,
			String rgid,
			String rgs,
			Boolean printHd,
			Boolean printSq,
			Boolean printPg) {
		
	}
	
	public void printHdLine(BTString o, String samver) {
		
	}
	
	public void printSqLines(BTString o) {
		
	}
	
	public void printPgLine(BTString o) {
		
	}
	
	public void printAlignedOptFlags(
			BTString o,               // output buffer
			Boolean first,                // first opt flag printed is first overall?
			Read rd,            // the read
			Read rdo,           // the opposite read
			AlignerResult res,               // individual alignment result
			StackedAlignment staln,         // stacked alignment
			AlnFlags flags,     // alignment flags
			AlnSetSumm summ,    // summary of alignments for this read
			SeedAlSumm ssm,     // seed alignment summary
			PerReadMetrics prm, // per-read metics
			Scoring sc,         // scoring scheme
			String mapqInp) {       // inputs to MAPQ calculation{
		
	}
	
	public Boolean omitSecondarySeqQuals() {
		return omitsec_;
	}
	
	public Boolean omitUnalignedReads() {
		return noUnal_;
	}
}
