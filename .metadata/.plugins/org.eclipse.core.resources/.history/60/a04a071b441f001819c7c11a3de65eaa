package com.uwb.bt2j.aligner.cache;

import com.uwb.bt2j.util.IndexTypes;
import com.uwb.bt2j.util.types.EList;
import com.uwb.bt2j.util.types.PList;
import com.uwb.bt2j.util.types.Pool;
import com.uwb.bt2j.util.types.RedBlack;
import com.uwb.bt2j.util.types.RedBlackNode;

class AlignmentCache {
  public static final int CACHE_PAGE_SZ = 16 * 1024;
  
  protected Pool pool_;
  protected RedBlack<QKey, QVal> qmap_;
  protected PList<QKey> qlist_;
  protected RedBlack<QKey, QVal> samap_;
  protected PList<Long> salist_;
  protected boolean shared_;
  protected double version;
  
  public AlignmentCache(long bytes, boolean shared) {
	  pool_ = new Pool(bytes, CACHE_PAGE_SZ);
	  qmap_ = new RedBlack(CACHE_PAGE_SZ,3);
	  qlist_ = new PList(3);
	  samap_ = new RedBlack(CACHE_PAGE_SZ,3);
	  salist_ = new PList(3);
	  shared_ = shared;
	  version_ = 0;
  }
  
  public void queryQVal(
		  QVal qv,
			EList<SATuple> satups,
			size_t nrange,
			size_t nelt,
			bool getLock)
  {
	  if(shared_ && getLock) {
			queryQvalImpl(qv, satups, nrange, nelt);
		} else {
			queryQvalImpl(qv, satups, nrange, nelt);
		}
  }
  
  public final Boolean empty() {
	  bool ret = qmap_.empty();
		return ret;
  }
  
  public QVal add(
		  QKey qk,
			bool added,
			bool getLock) {
	  if(shared_ && getLock) {
			return addImpl(qk, added);
		} else {
			return addImpl(qk, added);
		}
  }
  
  public boolean addOnTheFly(
		  QVal qv,         // qval that points to the range of reference substrings
			QKey sak, // the key holding the reference substring
			long topf,    // top range elt in BWT index
			long botf,    // bottom range elt in BWT index
			long topb,    // top range elt in BWT' index
			long botb,    // bottom range elt in BWT' index
			boolean getLock){
	  if(shared_ && getLock) {
			return addOnTheFlyImpl(qv, sak, topf, botf, topb, botb);
		} else {
			return addOnTheFlyImpl(qv, sak, topf, botf, topb, botb);
		}
  }
  
  public void clear() {
	  pool_.clear();
		qmap_.clear();
		qlist_.clear();
		samap_.clear();
		salist_.clear();
		version_++;
  }
  
  public double qNumKeys() {
	  return qmap_.size();
  }
  
  public double saNumKeys() {
	  return samap_.size();
  }
  
  public double qSize() {
	  return qlist_.size();
  }
  
  public double saSize() {
	  return salist_.size();
  }
  
  public Pool pool() {
	  return pool_;
  }
  
  public Boolean shared() {
	  return shared_;
  }
  
  public double version() {
	  return version_;
  }
  
  private void queryQvalImpl(
		  QVal qv,
			EList<SATuple> satups,
			size_t nrange,
			size_t nelt){
	  const size_t refi = qv.offset();
		const size_t reff = refi + qv.numRanges();
		// For each reference sequence sufficiently similar to the
		// query sequence in the QKey...
		for(size_t i = refi; i < reff; i++) {
			// Get corresponding SAKey, containing similar reference
			// sequence & length
			SAKey sak = qlist_.get(i);
			// Shouldn't have identical keys in qlist_
			assert(i == refi || qlist_.get(i) != qlist_.get(i-1));
			// Get corresponding SANode
			SANode *n = samap_.lookup(sak);
			assert(n != NULL);
			const SAVal& sav = n->payload;
			assert(sav.repOk(*this));
			if(sav.len > 0) {
				nrange++;
				satups.expand();
				satups.back().init(sak, sav.topf, sav.topb, TSlice(salist_, sav.i, sav.len));
				nelt += sav.len;
			}
		}
  }
  
  private boolean addOnTheFlyImpl(
		  	QVal qv,         // qval that points to the range of reference substrings
			QKey sak, // the key holding the reference substring
			long topf,    // top range elt in BWT index
			long botf,    // bottom range elt in BWT index
			long topb,    // top range elt in BWT' index
			long botb)    // bottom range elt in BWT' index
  {
	  boolean added = true;
		// If this is the first reference sequence we're associating with
		// the query sequence, initialize the QVal.
		if(!qv.valid()) {
			qv.init((int)qlist_.size(), 0, 0);
		}
		qv.addRange(botf-topf); // update tally for # ranges and # elts
		if(!qlist_.add(pool(), sak)) {
			return false; // Exhausted pool memory
		}

		assert_eq(qv.offset() + qv.numRanges(), qlist_.size());
		SANode s = samap_.add(pool(), sak, &added);
		if(s == null) {
			return false; // Exhausted pool memory
		}
		assert(s.key.repOk());
		if(added) {
			s.payload.i = (long)salist_.size();
			s.payload.len = botf - topf;
			s.payload.topf = topf;
			s.payload.topb = topb;
			for(int j = 0; j < (botf-topf); j++) {
				if(!salist_.add(pool(), IndexTypes.OFF_MASK)) {
					// Change the payload's len field
					s.payload.len = (long)j;
					return false; // Exhausted pool memory
				}
			}
		}
		// Now that we know all allocations have succeeded, we can do a few final
		// updates
		
		return true; 
  }
  
  private QVal addImpl(QKey qk, boolean added) {
	  RedBlackNode<QKey,QVal> n = qmap_.add(pool(), qk, added);
		return (n != null ? n.payload : null);
  }
}
