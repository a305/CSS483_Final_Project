package com.uwb.bt2j.aligner;

class Aligner {
	public static void main(String[] args) {
		try {
			// Reset all global state, including getopt state
			opterr = optind = 1;
			resetOptions();
			
			for(int i = 0; i < argc; i++) {
				argstr += argv[i];
				if(i < argc-1) argstr += " ";
			}
			
			if(startVerbose) {
				cerr << "Entered main(): ";
				logTime(cerr, true);
			}
			
			parseOptions(argc, argv);
			argv0 = argv[0];
			if(showVersion) {
				cout << argv0 << " version " << BOWTIE2_VERSION << endl;
				if(sizeof(void*) == 4) {
					cout << "32-bit" << endl;
				} else if(sizeof(void*) == 8) {
					cout << "64-bit" << endl;
				} else {
					cout << "Neither 32- nor 64-bit: sizeof(void*) = " << sizeof(void*) << endl;
				}
				
				cout << "Built on " << BUILD_HOST << endl;
				cout << BUILD_TIME << endl;
				cout << "Compiler: " << COMPILER_VERSION << endl;
				cout << "Options: " << COMPILER_OPTIONS << endl;
				cout << "Sizeof {int, long, long long, void*, size_t, off_t}: {"
						 << sizeof(int)
						 << ", " << sizeof(long) << ", " << sizeof(long long)
						 << ", " << sizeof(void *) << ", " << sizeof(size_t)
						 << ", " << sizeof(off_t) << "}" << endl;
				return 0;
			}
			{
				Timer _t(cerr, "Overall time: ", timing);
				if(startVerbose) {
					cerr << "Parsing index and read arguments: "; logTime(cerr, true);
				}

				// Get index basename (but only if it wasn't specified via --index)
				if(bt2index.empty()) {
					cerr << "No index, query, or output file specified!" << endl;
					printUsage(cerr);
					return 1;
				}
		
				if(thread_stealing && thread_stealing_dir.empty()) {
					cerr << "When --thread-ceiling is specified, must also specify --thread-piddir" << endl;
					printUsage(cerr);
					return 1;
				}

				// Get query filename
				bool got_reads = !queries.empty() || !mates1.empty() || !mates12.empty();
				
				if(optind >= argc) {
					if(!got_reads) {
						printUsage(cerr);
						cerr << "***" << endl
						     << "Error: Must specify at least one read input with -U/-1/-2" << endl;
						return 1;
					}
				} else if(!got_reads) {
					// Tokenize the list of query files
					tokenize(argv[optind++], ",", queries);
					if(queries.empty()) {
						cerr << "Tokenized query file list was empty!" << endl;
						printUsage(cerr);
						return 1;
					}
				}

				// Get output filename
				if(optind < argc && outfile.empty()) {
					outfile = argv[optind++];
					cerr << "Warning: Output file '" << outfile.c_str()
					     << "' was specified without -S.  This will not work in "
						 << "future Bowtie 2 versions.  Please use -S instead."
						 << endl;
				}

				// Extra parametesr?
				if(optind < argc) {
					cerr << "Extra parameter(s) specified: ";
					for(int i = optind; i < argc; i++) {
						cerr << "\"" << argv[i] << "\"";
						if(i < argc-1) cerr << ", ";
					}
					cerr << endl;
					if(mates1.size() > 0) {
						cerr << "Note that if <mates> files are specified using -1/-2, a <singles> file cannot" << endl
							 << "also be specified.  Please run bowtie separately for mates and singles." << endl;
					}
					throw 1;
				}

				// Optionally summarize
				if(gVerbose) {
					cout << "Input " + gEbwt_ext +" file: \"" << bt2index.c_str() << "\"" << endl;
					cout << "Query inputs (DNA, " << file_format_names[format].c_str() << "):" << endl;
					for(size_t i = 0; i < queries.size(); i++) {
						cout << "  " << queries[i].c_str() << endl;
					}
					cout << "Quality inputs:" << endl;
					for(size_t i = 0; i < qualities.size(); i++) {
						cout << "  " << qualities[i].c_str() << endl;
					}
					cout << "Output file: \"" << outfile.c_str() << "\"" << endl;
					cout << "Local endianness: " << (currentlyBigEndian()? "big":"little") << endl;
					cout << "Sanity checking: " << (sanityCheck? "enabled":"disabled") << endl;
				#ifdef NDEBUG
					cout << "Assertions: disabled" << endl;
				#else
					cout << "Assertions: enabled" << endl;
				#endif
				}
				if(ipause) {
					cout << "Press key to continue..." << endl;
					getchar();
				}
				driver<SString<char> >("DNA", bt2index, outfile);
			}
		#ifdef WITH_TBB
		#ifdef WITH_AFFINITY
			// Always disable observation before observers destruction
		   		//tracker.observe( false );
		   		pinner.observe( false );
		#endif
		#endif
			return 0;
		} catch(Exception e) {
			System.err.println("Error: Encountered exception: '" + e + "'");
			System.err.println("Command: ");
			for(int i = 0; i < argc; i++) cerr << argv[i] << " ";
			cerr << endl;
			return 1;
		} catch(int e) {
			if(e != 0) {
				System.err.println("Error: Encountered internal Bowtie 2 exception (#" + e + ")");
				System.err.println("Command: ");
				for(int i = 0; i < argc; i++)
					System.err.println(argv[i] + " ");
			}
			return e;
	}
	}
	
}