package com.uwb.bt2j.aligner.seed;

public class SeedResults {
	public SeedResults() {
		seqFw_ = seqRc_ = qualFw_ = qualRc_ = hitsFw_ = hitsRc_ = isFw_ = isRc_ = sortedFw_ = sortedRc_ = offIdx2off_ = rankOffs_ = rankFws_ = mm1Hit_ = 5;
		clear();
	}
	
	public void nextRead(Read read) {
		read_ = read;
	}
	
	public void add(
			QVal qv,           // range of ranges in cache
			AlignmentCache ac, // cache
			double seedIdx,         // seed index (from 5' end)
			boolean     seedFw) {
		if(qv.empty()) return;
		if(seedFw) {
			hitsFw_[seedIdx] = qv;
			numEltsFw_ += qv.numElts();
			numRangesFw_ += qv.numRanges();
			if(qv.numRanges() > 0) nonzFw_++;
		} else {
			hitsRc_[seedIdx] = qv;
			numEltsRc_ += qv.numElts();
			numRangesRc_ += qv.numRanges();
			if(qv.numRanges() > 0) nonzRc_++;
		}
		numElts_ += qv.numElts();
		numRanges_ += qv.numRanges();
		if(qv.numRanges() > 0) {
			nonzTot_++;
			if(qv.numRanges() == 1 && qv.numElts() == 1) {
				uniTot_++;
				uniTotS_[seedFw ? 0 : 1]++;
			} else {
				repTot_++;
				repTotS_[seedFw ? 0 : 1]++;
			}
		}
	}
	
	public void reset(Read read, EList<double> offIdx2off, double numOffs) {
		clearSeeds();
		numOffs_ = numOffs;
		seqFw_.resize(numOffs_);
		seqRc_.resize(numOffs_);
		qualFw_.resize(numOffs_);
		qualRc_.resize(numOffs_);
		hitsFw_.resize(numOffs_);
		hitsRc_.resize(numOffs_);
		isFw_.resize(numOffs_);
		isRc_.resize(numOffs_);
		sortedFw_.resize(numOffs_);
		sortedRc_.resize(numOffs_);
		offIdx2off_ = offIdx2off;
		for(double i = 0; i < numOffs_; i++) {
			sortedFw_[i] = sortedRc_[i] = false;
			hitsFw_[i].reset();
			hitsRc_[i].reset();
			isFw_[i].clear();
			isRc_[i].clear();
		}
		read_ = read;
		sorted_ = false;
	}
	
	public void clearSeeds() {
		sortedFw_.clear();
		sortedRc_.clear();
		rankOffs_.clear();
		rankFws_.clear();
		offIdx2off_.clear();
		hitsFw_.clear();
		hitsRc_.clear();
		isFw_.clear();
		isRc_.clear();
		seqFw_.clear();
		seqRc_.clear();
		nonzTot_ = 0;
		uniTot_ = uniTotS_[0] = uniTotS_[1] = 0;
		repTot_ = repTotS_[0] = repTotS_[1] = 0;
		nonzFw_ = 0;
		nonzRc_ = 0;
		numOffs_ = 0;
		numRanges_ = 0;
		numElts_ = 0;
		numRangesFw_ = 0;
		numEltsFw_ = 0;
		numRangesRc_ = 0;
		numEltsRc_ = 0;
	}
	
	public void clear() {
		clearSeeds();
		read_ = null;
		exactFwHit_.reset();
		exactRcHit_.reset();
		mm1Hit_.clear();
		mm1Sorted_ = false;
		mm1Elt_ = 0;
	}
	
	public void toSeedAlSumm(SeedAlSumm ssum) {
		// Number of positions with at least 1 range
				ssum.nonzTot   = nonzTot_;
				ssum.nonzFw    = nonzFw_;
				ssum.nonzRc    = nonzRc_;

				// Number of ranges
				ssum.nrangeTot = numRanges_;
				ssum.nrangeFw  = numRangesFw_;
				ssum.nrangeRc  = numRangesRc_;

				// Number of elements
				ssum.neltTot   = numElts_;
				ssum.neltFw    = numEltsFw_;
				ssum.neltRc    = numEltsRc_;
				
				// Other summaries
				ssum.maxNonzRangeFw = ssum.minNonzRangeFw = 0;
				ssum.maxNonzRangeRc = ssum.minNonzRangeRc = 0;
				ssum.maxNonzEltFw = ssum.minNonzEltFw = 0;
				ssum.maxNonzEltRc = ssum.minNonzEltRc = 0;
				for(double i = 0; i < numOffs_; i++) {
					if(hitsFw_[i].valid()) {
						if(ssum.minNonzEltFw == 0 || hitsFw_[i].numElts() < ssum.minNonzEltFw) {
							ssum.minNonzEltFw = hitsFw_[i].numElts();
						}
						if(ssum.maxNonzEltFw == 0 || hitsFw_[i].numElts() > ssum.maxNonzEltFw) {
							ssum.maxNonzEltFw = hitsFw_[i].numElts();
						}
						if(ssum.minNonzRangeFw == 0 || hitsFw_[i].numRanges() < ssum.minNonzRangeFw) {
							ssum.minNonzRangeFw = hitsFw_[i].numRanges();
						}
						if(ssum.maxNonzRangeFw == 0 || hitsFw_[i].numRanges() > ssum.maxNonzRangeFw) {
							ssum.maxNonzRangeFw = hitsFw_[i].numRanges();
						}
					}
					if(hitsRc_[i].valid()) {
						if(ssum.minNonzEltRc == 0 || hitsRc_[i].numElts() < ssum.minNonzEltRc) {
							ssum.minNonzEltRc = hitsRc_[i].numElts();
						}
						if(ssum.maxNonzEltRc == 0 || hitsRc_[i].numElts() > ssum.maxNonzEltRc) {
							ssum.maxNonzEltRc = hitsRc_[i].numElts();
						}
						if(ssum.minNonzRangeRc == 0 || hitsRc_[i].numRanges() < ssum.minNonzRangeRc) {
							ssum.minNonzRangeRc = hitsRc_[i].numRanges();
						}
						if(ssum.maxNonzRangeRc == 0 || hitsRc_[i].numRanges() > ssum.maxNonzRangeRc) {
							ssum.maxNonzRangeRc = hitsRc_[i].numRanges();
						}
					}
				}
	}
	
	public float averageHitsPerSeed() {
		return nonzTot_ == 0 ? 0 : (float)numElts_ / (float)nonzTot_;
	}
	
	public double numUniqueSeeds() {
		return uniTot_;
	}
	
	public double numUniqueSeedsStrand(boolean fw) {
		return uniTotS_[fw ? 0 : 1];
	}
	
	public double numRepeatSeeds() {
		return repTot_;
	}
	
	public double numRepeatSeedsStrand(boolean fw) {
		return repTotS_[fw ? 0 : 1];
	}
	
	public float medianHitsPerSeed() {
		EList<double> median = const_cast<EList<double>>(tmpMedian_);
		median.clear();
		for(double i = 0; i < numOffs_; i++) {
			if(hitsFw_[i].valid() && hitsFw_[i].numElts() > 0) {
				median.push_back(hitsFw_[i].numElts());
			}
			if(hitsRc_[i].valid() && hitsRc_[i].numElts() > 0) {
				median.push_back(hitsRc_[i].numElts());
			}
		}
		if(tmpMedian_.empty()) {
			return 0.0f;
		}
		median.sort();
		float med1 = (float)median[tmpMedian_.size() >> 1];
		float med2 = med1;
		if((median.size() & 1) == 0) {
			med2 = (float)median[(tmpMedian_.size() >> 1) - 1];
		}
		return med1 + med2 * 0.5f;
	}
	
	public double uniquenessFactor() {
		double result = 0.0;
		for(double i = 0; i < numOffs_; i++) {
			if(hitsFw_[i].valid()) {
				size_t nelt = hitsFw_[i].numElts();
				result += (1.0 / (double)(nelt * nelt));
			}
			if(hitsRc_[i].valid()) {
				size_t nelt = hitsRc_[i].numElts();
				result += (1.0 / (double)(nelt * nelt));
			}
		}
		return result;
	}
}
