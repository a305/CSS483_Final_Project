package com.uwb.bt2j.indexer;

import java.io.File;
import java.io.FileInputStream;
import java.io.OutputStream;
import java.io.PrintStream;

import com.uwb.bt2j.aligner.RandomSource;
import com.uwb.bt2j.util.IndexTypes;
import com.uwb.bt2j.util.RefReadInParams;
import com.uwb.bt2j.util.RefRecord;
import com.uwb.bt2j.util.file.FileBuf;
import com.uwb.bt2j.util.strings.BTDnaString;
import com.uwb.bt2j.util.types.EList;

public class Ebwt <TStr>{
	public static final String gEbwt_ext = "bt2";
	public String gLastIOErrMsg;
	boolean       _toBigEndian;
	int    _overrideOffRate;
	boolean       _verbose;
	boolean       _passMemExc;
	boolean       _sanity;
	boolean       fw_;     // true iff this is a forward index
	File       _in1;    // input fd for primary index file
	File       _in2;    // input fd for secondary index file
	String     _in1Str; // filename for primary index file
	String     _in2Str; // filename for secondary index file
	String     _inSaStr;  // filename for suffix-array file
	String     _inBwtStr; // filename for BWT file
	long  _zOff;
	long  _zEbwtByteOff;
	long   _zEbwtBpOff; 
	long  _nPat;  /// number of reference texts
	long  _nFrag; /// number of fragments
	
	APtrWrap<long> _plen;
	APtrWrap<long> _rstarts; // starting offset of fragments / text indexes
	// _fchr, _ftab and _eftab are expected to be relatively small
	// (usually < 1MB, perhaps a few MB if _fchr is particularly large
	// - like, say, 11).  For this reason, we don't bother with writing
	// them to disk through separate output streams; we
	APtrWrap<long> _fchr;
	APtrWrap<long> _ftab;
	APtrWrap<long> _eftab; // "extended" entries for _ftab
	// _offs may be extremely large.  E.g. for DNA w/ offRate=4 (one
	// offset every 16 rows), the total size of _offs is the same as
	// the total size of the input sequence
	APtrWrap<long> _offs;
	// _ebwt is the Extended Burrows-Wheeler Transform itself, and thus
	// is at least as large as the input sequence.
	APtrWrap<uint8_t> _ebwt;
	
	boolean       _useMm;        /// use memory-mapped files to hold the index
	boolean       useShmem_;     /// use shared memory to hold large parts of the index
	EList<String> _refnames; /// names of the reference sequences
	String mmFile1_;
	String mmFile2_;
	EbwtParams _eh;
	boolean packed_;

	static long default_bmax = IndexTypes.OFF_MASK;
	static long default_bmaxMultSqrt = IndexTypes.OFF_MASK;
	static long default_bmaxDivN = 4;
	static int      default_dcv = 1024;
	static boolean     default_noDc = false;
	static boolean     default_useBlockwise = true;
	static int default_seed = 0;
	static int      default_lineRate = 6;
	static int      default_offRate = 5;
	static int      default_offRatePlus = 0;
	static int      default_ftabChars = 10;
	static boolean     default_bigEndian = false;
	
	public enum EbwtFlags {
		EBWT_COLOR(2),
		EBWT_ENTIRE_REV(4);
		private int x;
		EbwtFlags(int y){x = y;}
	}
	
	public Ebwt(
			 int color,
			 int needEntireReverse,
		     boolean fw,
		     int overrideOffRate, // = -1,
		     int offRatePlus, // = -1,
		     boolean useMm, // = false,
		     boolean useShmem, // = false,
		     boolean mmSweep, // = false,
		     boolean loadNames, // = false,
			 boolean loadSASamp, // = true,
			 boolean loadFtab, // = true,
			 boolean loadRstarts, // = true,
		     boolean verbose, // = false,
		     boolean startVerbose, // = false,
		     boolean passMemExc, // = false,
		     boolean sanityCheck) {
		packed_ = false;
		_useMm = useMm;
		useShmem_ = useShmem;
		_in1Str = in + ".1." + gEbwt_ext;
		_in2Str = in + ".2." + gEbwt_ext;
		readIntoMemory(
			color,       // expect index to be colorspace?
			fw ? -1 : needEntireReverse, // need REF_READ_REVERSE
			loadSASamp,  // load the SA sample portion?
			loadFtab,    // load the ftab & eftab?
			loadRstarts, // load the rstarts array?
			true,        // stop after loading the header portion?
			_eh,        // params
			mmSweep,     // mmSweep
			loadNames,   // loadNames
			startVerbose); // startVerbose
		// If the offRate has been overridden, reflect that in the
		// _eh._offRate field
		if(offRatePlus > 0 && _overrideOffRate == -1) {
			_overrideOffRate = _eh._offRate + offRatePlus;
		}
		if(_overrideOffRate > _eh._offRate) {
			_eh.setOffRate(_overrideOffRate);
		}
	}
	
	public Ebwt(TStr exampleStr,
			boolean packed,
			int color,
			int needEntireReverse,
			int lineRate,
			int offRate,
			int ftabChars,
	        int nthreads,
			String file,   // base filename for EBWT files
			boolean fw,
			boolean useBlockwise,
			long bmax,
			long bmaxSqrtMult,
			long bmaxDivN,
			int dcv,
			EList<FileBuf> is,
			EList<RefRecord> szs,
			long sztot,
			RefReadInParams refparams,
			int seed,
			int overrideOffRate,
			boolean doSaFile,
			boolean doBwtFile,
			boolean verbose,
			boolean passMemExc,
			boolean sanityCheck) {
		_eh(
				joinedLen(szs),
				lineRate,
				offRate,
				ftabChars,
				color,
				refparams.reverse == REF_READ_REVERSE)
	}
  
	public String adjustEbwtBase(String cmdline, String ebwtFileBase, boolean verbose) {
		String str = ebwtFileBase;
		File in = new File((str + ".1." + gEbwt_ext));
		
		if(verbose) System.out.println( "Trying " + str);
		if(!in.exists())
			if(verbose) System.out.println( "  didn't work" );
			if(System.getenv("BOWTIE2_INDEXES") != null) {
				str = System.getenv("BOWTIE2_INDEXES") + "/" + ebwtFileBase;
				if(verbose) System.out.println( "Trying " + str);
				in=new File((str + ".1." + gEbwt_ext));
			}
		if(!in.exists()) {
			System.err.println("Could not locate a Bowtie index corresponding to basename \"" + ebwtFileBase + "\"" );
		}
		return str;
	}
	
	public TStr join(EList<TStr> l, int seed) {
		RandomSource rand; // reproducible given same seed
		rand.init(seed);
		TStr ret;
		long guessLen = 0;
		for(long i = 0; i < l.size(); i++) {
			guessLen += length(l[i]);
		}
		ret.resize(guessLen);
		long off = 0;
		for(int i = 0; i < l.size(); i++) {
			TStr s = l[i];
			for(int j = 0; j < s.size(); j++) {
				ret.set(s.get(j), off++);
			}
		}
		return ret;
	}
	public TStr join(
			EList<FileBuf> l,
            EList<RefRecord> szs,
            long sztot,
            RefReadInParams refparams,
            int seed) {
		RandomSource rand; // reproducible given same seed
		rand.init(seed);
		RefReadInParams rpcp = refparams;
		TStr ret;
		long guessLen = sztot;
		ret.resize(guessLen);
		long dstoff = 0;
		for(int i = 0; i < l.size(); i++) {
			// For each sequence we can pull out of istream l[i]...
			boolean first = true;
			while(!l.get(i).eof()) {
				RefRecord rec = fastaRefReadAppend(l.get(i), first, ret, dstoff, rpcp);
				first = false;
				long bases = rec.len;
				if(bases == 0) continue;
			}
		}
		return ret;
	}
	
	public void joinToDisk(
			EList<FileBuf> l,
			EList<RefRecord> szs,
			long sztot,
			RefReadInParams refparams,
			TStr ret,
			OutputStream out1,
			OutputStream out2
			) {
		RefReadInParams rpcp = refparams;
		// Not every fragment represents a distinct sequence - many
		// fragments may correspond to a single sequence.  Count the
		// number of sequences here by counting the number of "first"
		// fragments.
		this._nPat = 0;
		this._nFrag = 0;
		for(int i = 0; i < szs.size(); i++) {
			if(szs.get(i).len > 0) this._nFrag++;
			if(szs.get(i).first && szs.get(i).len > 0) this._nPat++;
		}
		_rstarts.reset();
		writeU<Long>(out1, this._nPat, this.toBe());
		// Allocate plen[]
		try {
			this._plen.init(new long[this._nPat], this._nPat);
		} catch(bad_alloc& e) {
			cerr << "Out of memory allocating plen[] in Ebwt::join()"
			     << " at " << __FILE__ << ":" << __LINE__ << endl;
			throw e;
		}
		// For each pattern, set plen
		TIndexOff npat = -1;
		for(long i = 0; i < szs.size(); i++) {
			if(szs.get(i).first && szs.get(i).len > 0) {
				if(npat >= 0) {
					writeU<Long>(out1, this.plen()[npat], this.toBe());
				}
				this.plen()[++npat] = (szs.get(i).len + szs.get(i).off);
			} else {
				// edge case, but we could get here with npat == -1
				// e.g. when building from a reference of all Ns
				if (npat < 0) npat = 0;
				this.plen()[npat] += (szs.get(i).len + szs.get(i).off);
			}
		}
		writeU<long>(out1, this.plen()[npat], this.toBe());
		// Write the number of fragments
		writeU<long>(out1, this._nFrag, this.toBe());
		long seqsRead = 0;
		long dstoff = 0;
		// For each filebuf
		for(int i = 0; i < l.size(); i++) {
			boolean first = true;
			long patoff = 0;
			// For each *fragment* (not necessary an entire sequence) we
			// can pull out of istream l[i]...
			while(!l.get(i).eof()) {
				String name;
				// Push a new name onto our vector
				_refnames.push_back("");
				RefRecord rec = fastaRefReadAppend(
					l.get(i), first, ret, dstoff, rpcp, _refnames.back());
				first = false;
				long bases = rec.len;
				if(rec.first && rec.len > 0) {
					if(_refnames.back().length() == 0) {
						// If name was empty, replace with an index
						OutputStream stm;
						stm.write(seqsRead);
						_refnames.back() = stm.str();
					}
				} else {
					// This record didn't actually start a new sequence so
					// no need to add a name
					//assert_eq(0, _refnames.back().length());
					_refnames.pop_back();
				}
				assert_lt(szsi, szs.size());
				assert_eq(rec.off, szs[szsi].off);
				assert_eq(rec.len, szs[szsi].len);
				assert_eq(rec.first, szs[szsi].first);
				assert(rec.first || rec.off > 0);
				ASSERT_ONLY(szsi++);
				// Increment seqsRead if this is the first fragment
				if(rec.first && rec.len > 0) seqsRead++;
				if(bases == 0) continue;
				assert_leq(bases, this.plen()[seqsRead-1]);
				// Reset the patoff if this is the first fragment
				if(rec.first) patoff = 0;
				patoff += rec.off; // add fragment's offset from end of last frag.
				// Adjust rpcps
				//uint32_t seq = seqsRead-1;
				ASSERT_ONLY(entsWritten++);
				// This is where rstarts elements are written to the output stream
				//writeU32(out1, oldRetLen, this.toBe()); // offset from beginning of joined string
				//writeU32(out1, seq,       this.toBe()); // sequence id
				//writeU32(out1, patoff,    this.toBe()); // offset into sequence
				patoff += bases;
			}
			assert_gt(szsi, 0);
			l[i].reset();
			assert(!l[i].eof());
	#ifndef NDEBUG
			int c = l[i].get();
			assert_eq('>', c);
			assert(!l[i].eof());
			l[i].reset();
			assert(!l[i].eof());
	#endif
		}
		assert_eq(entsWritten, this._nFrag);
	}
	
	public void joinedToTextOff(
			long qlen, 
			long off,
			long tidx,
			long textoff,
			long tlen,
			boolean rejectStraddle,
			boolean straddled){
		long top = 0;
		long bot = _nFrag; // 1 greater than largest addressable element
		long elt = IndexTypes.OFF_MASK;
		// Begin binary search
		while(true) {
			elt = top + ((bot - top) >> 1);
			long lower = rstarts()[elt*3];
			long upper;
			if(elt == _nFrag-1) {
				upper = _eh._len;
			} else {
				upper = rstarts()[((elt+1)*3)];
			}
			long fraglen = upper - lower;
			if(lower <= off) {
				if(upper > off) { // not last element, but it's within
					// off is in this range; check if it falls off
					if(off + qlen > upper) {
						straddled = true;
						if(rejectStraddle) {
							// it falls off; signal no-go and return
							tidx = IndexTypes.OFF_MASK;
							return;
						}
					}
					// This is the correct text idx whether the index is
					// forward or reverse
					tidx = rstarts()[(elt*3)+1];
					// it doesn't fall off; now calculate textoff.
					// Initially it's the number of characters that precede
					// the alignment in the fragment
					long fragoff = off - rstarts()[(elt*3)];
					if(!this.fw_) {
						fragoff = fraglen - fragoff - 1;
						fragoff -= (qlen-1);
					}
					// Add the alignment's offset into the fragment
					// ('fragoff') to the fragment's offset within the text
					textoff = fragoff + rstarts()[(elt*3)+2];
					break; // done with binary search
				} else {
					// 'off' belongs somewhere in the region between elt
					// and bot
					top = elt;
				}
			} else {
				// 'off' belongs somewhere in the region between top and
				// elt
				bot = elt;
			}
			// continue with binary search
		}
		tlen = this.plen()[tidx];
	}
	
	public long walkLeft(long row, long steps) {
		SideLocus l;
		if(steps > 0) l.initFromRow(row, _eh, ebwt());
		while(steps > 0) {
			if(row == _zOff) return IndexTypes.OFF_MASK;
			long newrow = this.mapLF(l);
			row = newrow;
			steps--;
			if(steps > 0) l.initFromRow(row, _eh, ebwt());
		}
		return row;
	}
	
	public long getOffset(long row) {
		if(row == _zOff) return 0;
		if((row & _eh._offMask) == row) return this.offs()[row >> _eh._offRate];
		long jumps = 0;
		SideLocus l;
		l.initFromRow(row, _eh, ebwt());
		while(true) {
			long newrow = this.mapLF(l);
			jumps++;
			row = newrow;
			if(row == _zOff) {
				return jumps;
			} else if((row & _eh._offMask) == row) {
				return jumps + this.offs()[row >> _eh._offRate];
			}
			l.initFromRow(row, _eh, ebwt());
		}
	}
	
	public long getOffset(long elt, boolean fw, long hitlen) {
		long off = getOffset(elt);
		if(!fw) {
			off = _eh._len - off - 1;
			off -= (hitlen-1);
		}
		return off;
	}
	
	public boolean contains(BTDnaString str, long otop, long obot) {
		SideLocus tloc, bloc;
		if(str.empty()) {
			if(otop != null && obot != null) otop = obot = 0;
			return true;
		}
		int c = str[str.length()-1];
		long top = 0, bot = 0;
		if(c < 4) {
			top = fchr()[c];
			bot = fchr()[c+1];
		} else {
			boolean set = false;
			for(int i = 0; i < 4; i++) {
				if(fchr()[c] < fchr()[c+1]) {
					if(set) {
						return false;
					} else {
						set = true;
						top = fchr()[c];
						bot = fchr()[c+1];
					}
				}
			}
		}
		tloc.initFromRow(top, eh(), ebwt());
		bloc.initFromRow(bot, eh(), ebwt());
		for(long i = (long)str.length()-2; i >= 0; i--) {
			c = str[i];
			if(c <= 3) {
				top = mapLF(tloc, c);
				bot = mapLF(bloc, c);
			} else {
				long sz = bot - top;
				int c1 = mapLF1(top, tloc);
				bot = mapLF(bloc, c1);
				if(bot - top < sz) {
					// Encountered an N and could not proceed through it because
					// there was more than one possible nucleotide we could replace
					// it with
					return false;
				}
			}
			if(i > 0) {
				tloc.initFromRow(top, eh(), ebwt());
				bloc.initFromRow(bot, eh(), ebwt());
			}
		}
		if(otop != null && obot != null) {
			otop = top; obot = bot;
		}
		return bot > top;
	}
	
	public static long fileSize(String name) {
		File f = new File(name);
		return f.length();
	}
	
	public static int pop32(long x) {
		// Lots of cache misses on following lines (>10K)
		x = x - ((x >> 1) & 0x55555555);
		x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		x = (x + (x >> 4)) & 0x0F0F0F0F;
		x = x + (x >> 8);
		x = x + (x >> 16);
		x = x + (x >> 32);
		return (int)(x & 0x3F);
	}
	
	public static int countInU64(int c, long dw) {
		long c_table[] = {
				0xffffffff,
				0xaaaaaaaa,
				0x55555555,
				0x00000000
		};
		long c0 = c_table[c];
		long x0 = dw ^ c0;
		long x1 = (x0 >> 1);
		long x2 = x1 & (0x55555555);
		long x3 = x0 & x2;
	    long tmp = pop32(x3);
		return (int) tmp;
	}
	
	public EbwtParams eh() {
		return _eh;
	}
	
	public boolean ftabLoHi(
			BTDnaString seq, // sequence to extract from
			int off,             // offset into seq to begin extracting
			boolean rev,               // reverse while extracting
			long top,
			long bot)
			) {
		long fi = ftabSeqToInt(seq, off, rev);
		if(fi == Long.MAX_VALUE) {
			return false;
		}
		top = ftabHi(fi);
		bot = ftabLo(fi+1);
		return true;
	}
			
	public long fchr() {
		return _fchr.get();
	}
	
	public byte ebwt() {
		return _ebwt.get();
	}
	
	public long mapLF(SideLocus l) {
		long ret;
		int c = rowL(l);
		ret = countBt2Side(l, c);
		return ret;
	}
	
	public long mapLF1(long row, SideLocus l, int c) {
		if(rowL(l) != c || row == _zOff) return IndexTypes.OFF_MASK;
		long ret = countBt2Side(l, c);
		return ret;
	}
	
	private PrintStream log() {
		return System.out;
	}
	
	public boolean verbose() {
		return _verbose;
	}
	
	private void verbose(String s) {
		if(verbose()) {
			log().println(s);
			log().flush();
		}
	}
}
