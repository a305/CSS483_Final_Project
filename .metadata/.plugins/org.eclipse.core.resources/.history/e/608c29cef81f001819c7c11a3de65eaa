package com.uwb.bt2j.indexer;

public class DifferenceCoverSample <TStr>{
	public static int dc0to64[][] = {
			{0xffffffff},                     // 0
			{0xffffffff},                     // 1
			{0xffffffff},                     // 2
			{1, 0},                           // 3
			{1, 2, 0},                        // 4
			{1, 2, 0},                        // 5
			{1, 3, 0},                        // 6
			{1, 3, 0},                        // 7
			{1, 2, 4, 0},                     // 8
			{1, 2, 4, 0},                     // 9
			{1, 2, 5, 0},                     // 10
			{1, 2, 5, 0},                     // 11
			{1, 3, 7, 0},                     // 12
			{1, 3, 9, 0},                     // 13
			{1, 2, 3, 7, 0},                  // 14
			{1, 2, 3, 7, 0},                  // 15
			{1, 2, 5, 8, 0},                  // 16
			{1, 2, 4, 12, 0},                 // 17
			{1, 2, 5, 11, 0},                 // 18
			{1, 2, 6, 9, 0},                  // 19
			{1, 2, 3, 6, 10, 0},              // 20
			{1, 4, 14, 16, 0},                // 21
			{1, 2, 3, 7, 11, 0},              // 22
			{1, 2, 3, 7, 11, 0},              // 23
			{1, 2, 3, 7, 15, 0},              // 24
			{1, 2, 3, 8, 12, 0},              // 25
			{1, 2, 5, 9, 15, 0},              // 26
			{1, 2, 5, 13, 22, 0},             // 27
			{1, 4, 15, 20, 22, 0},            // 28
			{1, 2, 3, 4, 9, 14, 0},           // 29
			{1, 2, 3, 4, 9, 19, 0},           // 30
			{1, 3, 8, 12, 18, 0},             // 31
			{1, 2, 3, 7, 11, 19, 0},          // 32
			{1, 2, 3, 6, 16, 27, 0},          // 33
			{1, 2, 3, 7, 12, 20, 0},          // 34
			{1, 2, 3, 8, 12, 21, 0},          // 35
			{1, 2, 5, 12, 14, 20, 0},         // 36
			{1, 2, 4, 10, 15, 22, 0},         // 37
			{1, 2, 3, 4, 8, 14, 23, 0},       // 38
			{1, 2, 4, 13, 18, 33, 0},         // 39
			{1, 2, 3, 4, 9, 14, 24, 0},       // 40
			{1, 2, 3, 4, 9, 15, 25, 0},       // 41
			{1, 2, 3, 4, 9, 15, 25, 0},       // 42
			{1, 2, 3, 4, 10, 15, 26, 0},      // 43
			{1, 2, 3, 6, 16, 27, 38, 0},      // 44
			{1, 2, 3, 5, 12, 18, 26, 0},      // 45
			{1, 2, 3, 6, 18, 25, 38, 0},      // 46
			{1, 2, 3, 5, 16, 22, 40, 0},      // 47
			{1, 2, 5, 9, 20, 26, 36, 0},      // 48
			{1, 2, 5, 24, 33, 36, 44, 0},     // 49
			{1, 3, 8, 17, 28, 32, 38, 0},     // 50
			{1, 2, 5, 11, 18, 30, 38, 0},     // 51
			{1, 2, 3, 4, 6, 14, 21, 30, 0},   // 52
			{1, 2, 3, 4, 7, 21, 29, 44, 0},   // 53
			{1, 2, 3, 4, 9, 15, 21, 31, 0},   // 54
			{1, 2, 3, 4, 6, 19, 26, 47, 0},   // 55
			{1, 2, 3, 4, 11, 16, 33, 39, 0},  // 56
			{1, 3, 13, 32, 36, 43, 52, 0},    // 57

			// Generated by calcExhaustiveDC()
			{1, 2, 3, 7, 21, 33, 37, 50, 0},  // 58
			{1, 2, 3, 6, 13, 21, 35, 44, 0},  // 59
			{1, 2, 4, 9, 15, 25, 30, 42, 0},  // 60
			{1, 2, 3, 7, 15, 25, 36, 45, 0},  // 61
			{1, 2, 4, 10, 32, 39, 46, 51, 0}, // 62
			{1, 2, 6, 8, 20, 38, 41, 54, 0},  // 63
			{1, 2, 5, 14, 16, 34, 42, 59, 0}  // 64
	};
	
	public boolean dcRepOk(TStr v, EList<TStr> ds) {
		// diffs[] records all the differences observed
		boolean[] covered(v, EBWT_CAT);
		for(T i = 1; i < v; i++) {
			covered[i] = false;
		}
		for(TStr di = TStr(); di < ds.size(); di++) {
			for(T dj = di+1; dj < ds.size(); dj++) {
				T d1 = (ds[dj] - ds[di]);
				T d2 = (ds[di] + v - ds[dj]);
				covered[d1] = true;
				covered[d2] = true;
			}
		}
		boolean ok = true;
		for(T i = 1; i < v; i++) {
			if(covered[i] == false) {
				ok = false;
				break;
			}
		}
		return ok;
	}
	
	public boolean increasing(T ts, int limit) {
		for(int i = 0; i < limit-1; i++) {
			if(ts[i+1] <= ts[i]) return false;
		}
		return true;
	}
	
	public boolean hasDifference(T ds, T d, T v, T diff) {
		// diffs[] records all the differences observed
		for(T di = T(); di < d; di++) {
			for(T dj = di+1; dj < d; dj++) {
				T d1 = (ds[dj] - ds[di]);
				T d2 = (ds[di] + v - ds[dj]);
				if(d1 == diff || d2 == diff) return true;
			}
		}
		return false;
	}
	
	public void calcExhaustiveDC(T i, boolean verbose, boolean sanityCheck) {
		T v = i;
		boolean[] diffs(v, EBWT_CAT);
		// v is the target period
		T ld = (T)ceil(sqrt(v));
		// ud is the upper bound on |D|
		T ud = v / 2;
		// for all possible |D|s
		boolean ok = true;
		T *ds = null;
		T d;
		for(d = ld; d <= ud+1; d++) {
			// for all possible |D| samples
			AutoArray<T> ds(d, EBWT_CAT);
			for(T j = 0; j < d; j++) {
				ds[j] = j;
			}
			assert(increasing(ds, d));
			while(true) {
				// reset diffs[]
				for(T t = 1; t < v; t++) {
					diffs[t] = false;
				}
				T diffCnt = 0;
				// diffs[] records all the differences observed
				for(T di = 0; di < d; di++) {
					for(T dj = di+1; dj < d; dj++) {
						T d1 = (ds[dj] - ds[di]);
						T d2 = (ds[di] + v - ds[dj]);
						if(!diffs[d1]) diffCnt++; diffs[d1] = true;
						if(!diffs[d2]) diffCnt++; diffs[d2] = true;
					}
				}
				// Do we observe all possible differences (except 0)
				ok = diffCnt == v-1;
				if(ok) {
					// Yes, all differences are covered
					break;
				} else {
					// Advance ds
					// (Following is commented out because it turns out
					// it's slow)
					// Find a missing difference
					//uint32_t missing = 0xffffffff;
					//for(uint32_t t = 1; t < v; t++) {
					//	if(diffs[t] == false) {
					//		missing = diffs[t];
					//		break;
					//	}
					//}
					//assert_neq(missing, 0xffffffff);
					boolean advanced = false;
					boolean keepGoing = false;
					do {
						keepGoing = false;
						for(T bd = d-1; bd > 1; bd--) {
							T dif = (d-1)-bd;
							if(ds[bd] < v-1-dif) {
								ds[bd]++;
								// Reset subsequent ones
								for(T bdi = bd+1; bdi < d; bdi++) {
									ds[bdi] = ds[bdi-1]+1;
								}
								// (Following is commented out because
								// it turns out it's slow)
								// See if the new DC has the missing value
								//if(!hasDifference(ds, d, v, missing)) {
								//	keepGoing = true;
								//	break;
								//}
								advanced = true;
								break;
							} else {
								ds[bd] = 0;
								// keep going
							}
						}
					} while(keepGoing);
					// No solution for this |D|
					if(!advanced) break;
				}
			} // next sample assignment
			if(ok) {
				break;
			}
		} // next |D|
		System.out.println("Did exhaustive v=" + v + " |D|=" + d );
		System.out.print("  ");
		for(T i = 0; i < d; i++) {
			System.out.print( ds[i]);
			if(i < d-1) System.out.print(",");
		}
		System.out.println();
	}
	
	public void calcColbournAndLingDCs(boolean verbose, boolean sanityCheck) {
		for(T r = 0; r < 16; r++) {
			T maxv = 24*r*r + 36*r + 13; // Corollary 2.3
			T numsamp = 6*r + 4;
			clDCs[r].maxV = maxv;
			clDCs[r].numSamples = numsamp;
			T i;
			// clDCs[r].samples[0] = 0;
			// Fill in the 1^r part of the B series
			for(i = 1; i < r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 1;
			}
			// Fill in the (r + 1)^1 part
			clDCs[r].samples[r+1] = clDCs[r].samples[r] + r + 1;
			// Fill in the (2r + 1)^r part
			for(i = r+2; i < r+2+r; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 2*r + 1;
			}
			// Fill in the (4r + 3)^(2r + 1) part
			for(i = r+2+r; i < r+2+r+2*r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 4*r + 3;
			}
			// Fill in the (2r + 2)^(r + 1) part
			for(i = r+2+r+2*r+1; i < r+2+r+2*r+1+r+1; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 2*r + 2;
			}
			// Fill in the last 1^r part
			for(i = r+2+r+2*r+1+r+1; i < r+2+r+2*r+1+r+1+r; i++) {
				clDCs[r].samples[i] = clDCs[r].samples[i-1] + 1;
			}
			if(sanityCheck) {
				// diffs[] records all the differences observed
				boolean[] diffs(maxv, EBWT_CAT);
				for(T i = 0; i < numsamp; i++) {
					for(T j = i+1; j < numsamp; j++) {
						T d1 = (clDCs[r].samples[j] - clDCs[r].samples[i]);
						T d2 = (clDCs[r].samples[i] + maxv - clDCs[r].samples[j]);
						diffs[d1] = true;
						diffs[d2] = true;
					}
				}
				// Should have observed all possible differences (except 0)
				for(T i = 1; i < maxv; i++) {
					if(diffs[i] == false) System.out.println(r + ", " + i);
				}
			}
		}
		clDCs_calced = true;
	}
	
	public EList<T> getDiffCover(T v, boolean verbose, boolean snityCheck) {
		EList<T> ret;
		ret.clear();
		// Can we look it up in our hardcoded array?
		if(v <= 64 && dc0to64[v][0] == 0xffffffff) {
			if(verbose) System.out.println( "v in hardcoded area, but hardcoded entry was all-fs");
			return ret;
		} else if(v <= 64) {
			ret.push_back(0);
			for(int i = 0; i < 10; i++) {
				if(dc0to64[v][i] == 0) break;
				ret.push_back(dc0to64[v][i]);
			}
			if(sanityCheck) assert(dcRepOk(v, ret));
			return ret;
		}

		// Can we look it up in our calcColbournAndLingDCs array?
		if(!clDCs_calced) {
			calcColbournAndLingDCs<uint32_t>(verbose, sanityCheck);
			assert(clDCs_calced);
		}
		for(int i = 0; i < 16; i++) {
			if(v <= clDCs[i].maxV) {
				for(int j = 0; j < clDCs[i].numSamples; j++) {
					T s = clDCs[i].samples[j];
					if(s >= v) {
						s %= v;
						for(int k = 0; k < ret.size(); k++) {
							if(s == ret[k]) break;
							if(s < ret[k]) {
								ret.insert(s, k);
								break;
							}
						}
					} else {
						ret.push_back(s % v);
					}
				}
				return ret;
			}
		}
		System.err.println("Error: Could not find a difference cover sample for v=" + v);
		throw 1;
	}
}
