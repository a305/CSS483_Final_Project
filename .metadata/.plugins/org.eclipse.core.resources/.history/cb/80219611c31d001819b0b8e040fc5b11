package com.uwb.bt2j.aligner;

import com.uwb.bt2j.util.strings.BTDnaString;
import com.uwb.bt2j.util.strings.BTString;

public class SwAligner {
	public void initRead(
			BTDnaString rdfw, // forward read sequence
			BTDnaString rdrc, // revcomp read sequence
			BTString qufw,    // forward read qualities
			BTString qurc,    // reverse read qualities
			double rdi,              // offset of first read char to align
			double rdf,              // offset of last read char to align
			Scoring sc)       // scoring scheme
	{
		int nceil = sc.nCeil.f<Integer>((double)rdfw.length());
		rdfw_    = rdfw;      // read sequence
		rdrc_    = rdrc;      // read sequence
		qufw_    = qufw;      // read qualities
		qurc_    = qurc;      // read qualities
		rdi_     = rdi;        // offset of first read char to align
		rdf_     = rdf;        // offset of last read char to align
		sc_      = sc;        // scoring scheme
		nceil_   = nceil;      // max # Ns allowed in ref portion of aln
		readSse16_ = false;    // true -> sse16 from now on for this read
		initedRead_ = true;

		if(dpLog_ != null) {
			if(!firstRead_) {
				dpLog_.write('\n');
			}
			dpLog_.write(rdfw.toZBuf() + '\t' + qufw.toZBuf());
		}
		firstRead_ = false;
	}
	
	public void initRef(
			Boolean fw,               // whether to forward or revcomp read is aligning
			TRefId refidx,         // id of reference aligned against
			const DPRect rect,    // DP rectangle
			char rf,              // reference sequence
			size_t rfi,            // offset of first reference char to align to
			size_t rff,            // offset of last reference char to align to
			TRefOff reflen,        // length of reference sequence
			const Scoring sc,     // scoring scheme
			TAlScore minsc,        // minimum score
			Boolean enable8,          // use 8-bit SSE if possible?
			size_t cminlen,        // minimum length for using checkpointing scheme
			size_t cpow2,          // interval b/t checkpointed diags; 1 << this
			Boolean doTri,            // triangular mini-fills?
			Boolean extend)           // is this a seed extension?
			{
		size_t readGaps = sc.maxReadGaps(minsc, rdfw_->length());
		size_t refGaps  = sc.maxRefGaps(minsc, rdfw_->length());
		assert_geq(readGaps, 0);
		assert_geq(refGaps, 0);
		assert_gt(rff, rfi);
		rdgap_       = readGaps;  // max # gaps in read
		rfgap_       = refGaps;   // max # gaps in reference
		state_       = STATE_INITED;
		fw_          = fw;       // orientation
		rd_          = fw ? rdfw_ : rdrc_; // read sequence
		qu_          = fw ? qufw_ : qurc_; // quality sequence
		refidx_      = refidx;   // id of reference aligned against
		rf_          = rf;       // reference sequence
		rfi_         = rfi;      // offset of first reference char to align to
		rff_         = rff;      // offset of last reference char to align to
		reflen_      = reflen;   // length of entire reference sequence
		rect_        = &rect;    // DP rectangle
		minsc_       = minsc;    // minimum score
		cural_       = 0;        // idx of next alignment to give out
		initedRef_   = true;     // indicate we've initialized the ref portion
		enable8_     = enable8;  // use 8-bit SSE if possible?
		extend_      = extend;   // true iff this is a seed extension
		cperMinlen_  = cminlen;  // reads shorter than this won't use checkpointer
		cperPerPow2_ = cpow2;    // interval b/t checkpointed diags; 1 << this
		cperEf_      = true;     // whether to checkpoint H, E, and F
		cperTri_     = doTri;    // triangular mini-fills?
		bter_.initRef(
			fw_ ? rdfw_->buf() : // in: read sequence
				  rdrc_->buf(), 
			fw_ ? qufw_->buf() : // in: quality sequence
				  qurc_->buf(),
			rd_->length(),       // in: read sequence length
			rf_ + rfi_,          // in: reference sequence
			rff_ - rfi_,         // in: in-rectangle reference sequence length
			reflen,              // in: total reference sequence length
			refidx_,             // in: reference id
			rfi_,                // in: reference offset
			fw_,                 // in: orientation
			rect_,               // in: DP rectangle
			&cper_,              // in: checkpointer
			*sc_,                // in: scoring scheme
			nceil_);             // in: N ceiling
		// Record the reference sequence in the log
		if(dpLog_ != NULL) {
			(*dpLog_) << '\t';
			(*dpLog_) << refidx_ << ',';
			(*dpLog_) << reflen_ << ',';
			(*dpLog_) << minsc_ << ',';
			(*dpLog_) << (fw ? '+' : '-') << ',';
			rect_->write(*dpLog_);
			(*dpLog_) << ',';
			for(TRefOff i = rfi_; i < rff_; i++) {
				(*dpLog_) << mask2dna[(int)rf[i]];
			}
		}
	}
	
	public void initRef(
			bool fw,               // whether to forward or revcomp read is aligning
			TRefId refidx,         // reference aligned against
			const DPRect rect,    // DP rectangle
			const BitPairReference refs, // Reference strings
			TRefOff reflen,        // length of reference sequence
			const Scoring sc,     // scoring scheme
			TAlScore minsc,        // minimum score
			bool enable8,          // use 8-bit SSE if possible?
			size_t cminlen,        // minimum length for using checkpointing scheme
			size_t cpow2,          // interval b/t checkpointed diags; 1 << this
			bool doTri,            // triangular mini-fills?
			bool extend,           // true iff this is a seed extension
			size_t  upto,          // count the number of Ns up to this offset
			size_t& nsUpto)        // output: the number of Ns up to 'upto'
			{
		
	}
}
