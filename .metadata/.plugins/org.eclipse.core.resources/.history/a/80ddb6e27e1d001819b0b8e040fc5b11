package com.uwb.bt2j.aligner.seed;

import com.uwb.bt2j.aligner.cache.QKey;
import com.uwb.bt2j.indexer.SideLocus;

import javafx.util.Pair;

public class SeedAligner {
	public enum SeedAlignerActions {
		SA_ACTION_TYPE_RESET(1),
				SA_ACTION_TYPE_SEARCH_SEED(2), // 2
				SA_ACTION_TYPE_FTAB(3),        // 3
				SA_ACTION_TYPE_FCHR(4),        // 4
				SA_ACTION_TYPE_MATCH(5),       // 5
				SA_ACTION_TYPE_EDIT(6);         // 6
				private int x;
		SeedAlignerActions(int y) {
			x = y;
		}
	}
	
	public void instantiateSeq(Read read, BTDnaString seq, BTString qual, int len, int depth, Boolean fw) {
		// Fill in 'seq' and 'qual'
		int seedlen = len;
		if((int)read.length() < seedlen) seedlen = (int)read.length();
		seq.resize(len);
		qual.resize(len);
		// If fw is false, we take characters starting at the 3' end of the
		// reverse complement of the read.
		for(int i = 0; i < len; i++) {
			seq.set(read.patFw.windowGetDna(i, fw, depth, len), i);
			qual.set(read.qual.windowGet(i, fw, depth, len), i);
		}
	}
	
	public Pair<Integer, Integer> instantiateSeeds(
			EList<Seed> seeds,
			double off,
			int per,
			Read read,
			Scoring pens,
			Boolean nofw,
			Boolean norc,
			AlignmentCacheIFace cache,
			SeedResults sr,
			SeedSearchMetrics met,
			Pair<Integer, Integer> instFw,
			Pair<Integer, Integer> instRc) {
		offIdx2off_.clear();
		int len = seeds[0].len; // assume they're all the same length
		// Calc # seeds within read interval
		int nseeds = 1;
		if((int)read.length() - (int)off > len) {
			nseeds += ((int)read.length() - (int)off - len) / per;
		}
		for(int i = 0; i < nseeds; i++) {
			offIdx2off_.push_back(per * i + (int)off);
		}
		Pair<Integer, Integer> ret;
		ret.first = 0;  // # seeds that require alignment
		ret.second = 0; // # seeds that hit in cache with non-empty results
		sr.reset(read, offIdx2off_, nseeds);
		// For each seed position
		for(int fwi = 0; fwi < 2; fwi++) {
			Boolean fw = (fwi == 0);
			if((fw && nofw) || (!fw && norc)) {
				// Skip this orientation b/c user specified --nofw or --norc
				continue;
			}
			// For each seed position
			for(int i = 0; i < nseeds; i++) {
				int depth = i * per + (int)off;
				int seedlen = seeds[0].len;
				// Extract the seed sequence at this offset
				// If fw == true, we extract the characters from i*per to
				// i*(per-1) (exclusive).  If fw == false, 
				instantiateSeq(
					read,
					sr.seqs(fw)[i],
					sr.quals(fw)[i],
					Integer.min((int)seedlen, (int)read.length()),
					depth,
					fw);
				QKey qk(sr.seqs(fw)[i]);
				// For each search strategy
				EList<InstantiatedSeed>& iss = sr.instantiatedSeeds(fw, i);
				for(int j = 0; j < (int)seeds.size(); j++) {
					iss.expand();
					assert_eq(seedlen, seeds[j].len);
					InstantiatedSeed is = iss.back();
					if(seeds[j].instantiate(
						read,
						sr.seqs(fw)[i],
						sr.quals(fw)[i],
						pens,
						depth,
						i,
						j,
						fw,
						is))
					{
						// Can we fill this seed hit in from the cache?
						ret.first++;
						if(fwi == 0) { instFw.first++; } else { instRc.first++; }
					} else {
						// Seed may fail to instantiate if there are Ns
						// that prevent it from matching
						met.filteredseed++;
						iss.pop_back();
					}
				}
			}
		}
		return ret;
	}
	
	public void searchAllSeeds(
			EList<Seed> seeds,
			Ebwt ebwtFw,
			Ebwt ebwtBw,
			Read read,
			Scoring pens,
			AlignmentCacheIface cache,
			SeedResults sr,
			SeedSearchMetrics met,
			PerReadMetrics prm) {
		ebwtFw_ = ebwtFw;
		ebwtBw_ = ebwtBw;
		sc_ = pens;
		read_ = read;
		ca_ = cache;
		bwops_ = bwedits_ = 0;
		long possearches = 0, seedsearches = 0, intrahits = 0, interhits = 0, ooms = 0;
		// For each instantiated seed
		for(int i = 0; i < (int)sr.numOffs(); i++) {
			double off = sr.idx2off(i);
			for(int fwi = 0; fwi < 2; fwi++) {
				Boolean fw = (fwi == 0);
				EList<InstantiatedSeed> iss = sr.instantiatedSeeds(fw, i);
				if(iss.empty()) {
					// Cache hit in an across-read cache
					continue;
				}
				QVal qv;
				seq_  = sr.seqs(fw)[i];  // seed sequence
				qual_ = sr.quals(fw)[i]; // seed qualities
				off_  = off;              // seed offset (from 5')
				fw_   = fw;               // seed orientation
				// Tell the cache that we've started aligning, so the cache can
				// expect a series of on-the-fly updates
				int ret = cache.beginAlign(seq_, qual_, qv);
				if(ret == -1) {
					// Out of memory when we tried to add key to map
					ooms++;
					continue;
				}
				Boolean abort = false;
				if(ret == 0) {
					// Not already in cache
					possearches++;
					for(double j = 0; j < iss.size(); j++) {
						// Set seq_ and qual_ appropriately, using the seed sequences
						// and qualities already installed in SeedResults
						s_ = iss[j];
						// Do the search with respect to seq_, qual_ and s_.
						if(!searchSeedBi()) {
							// Memory exhausted during search
							ooms++;
							abort = true;
							break;
						}
						seedsearches++;
					}
					if(!abort) {
						qv = cache.finishAlign();
					}
				} else {
					// Already in cache
					intrahits++;
				}
				if(qv.valid()) {
					sr.add(
						qv,    // range of ranges in cache
						cache.current(), // cache
						i,     // seed index (from 5' end)
						fw);   // whether seed is from forward read
				}
			}
		}
		prm.nSeedRanges = sr.numRanges();
		prm.nSeedElts = sr.numElts();
		prm.nSeedRangesFw = sr.numRangesFw();
		prm.nSeedRangesRc = sr.numRangesRc();
		prm.nSeedEltsFw = sr.numEltsFw();
		prm.nSeedEltsRc = sr.numEltsRc();
		prm.seedMedian = (uint64_t)(sr.medianHitsPerSeed() + 0.5);
		prm.seedMean = (uint64_t)sr.averageHitsPerSeed();

		prm.nSdFmops += bwops_;
		met.seedsearch += seedsearches;
		met.nrange += sr.numRanges();
		met.nelt += sr.numElts();
		met.possearch += possearches;
		met.intrahit += intrahits;
		met.interhit += interhits;
		met.ooms += ooms;
		met.bwops += bwops_;
		met.bweds += bwedits_;
	}
	
	public Boolean sanityPartial(
			Ebwt ebwtRw,
			Ebwt ebwtBw,
			BTDnaString seq,
			double dep,
			double len,
			Boolean do1mm,
			long topFw,
			long botfw,
			long topbw,
			long botbw) {
		tmpdnastr_.clear();
		for(double i = dep; i < len; i++) {
			tmpdnastr_.append(seq[i]);
		}
		long top_fw = 0, bot_fw = 0;
		ebwtFw.contains(tmpdnastr_, top_fw, bot_fw);
		if(do1mm && ebwtBw != null) {
			tmpdnastr_.reverse();
			TIndexOffU top_bw = 0, bot_bw = 0;
			ebwtBw.contains(tmpdnastr_, top_bw, bot_bw);
		}
		return true;
	}
	
	public double exactSweep(
			Ebwt ebwt,
			Read read,
			Scoring sc,
			Boolean nofw,
			Boolean norc,
			double mineMax,
			double mineFw,
			double mineRc,
			Boolean repex,
			SeedResults hits,
			SeedSearchMetrics met) {
		long top = 0, bot = 0;
		SideLocus tloc, bloc;
		double len = read.length();
		size_t nelt = 0;
		for(int fwi = 0; fwi < 2; fwi++) {
			bool fw = (fwi == 0);
			if( fw && nofw) continue;
			if(!fw && norc) continue;
			const BTDnaString& seq = fw ? read.patFw : read.patRc;
			assert(!seq.empty());
			int ftabLen = ebwt.eh().ftabChars();
			size_t dep = 0;
			size_t nedit = 0;
			bool done = false;
			while(dep < len && !done) {
				top = bot = 0;
				size_t left = len - dep;
				assert_gt(left, 0);
				bool doFtab = ftabLen > 1 && left >= (size_t)ftabLen;
				if(doFtab) {
					// Does N interfere with use of Ftab?
					for(size_t i = 0; i < (size_t)ftabLen; i++) {
						int c = seq[len-dep-1-i];
						if(c > 3) {
							doFtab = false;
							break;
						}
					}
				}
				if(doFtab) {
					// Use ftab
					ebwt.ftabLoHi(seq, len - dep - ftabLen, false, top, bot);
					dep += (size_t)ftabLen;
				} else {
					// Use fchr
					int c = seq[len-dep-1];
					if(c < 4) {
						top = ebwt.fchr()[c];
						bot = ebwt.fchr()[c+1];
					}
					dep++;
				}
				if(bot <= top) {
					nedit++;
					if(nedit >= mineMax) {
						if(fw) { mineFw = nedit; } else { mineRc = nedit; }
						break;
					}
					continue;
				}
				INIT_LOCS(top, bot, tloc, bloc, ebwt);
				// Keep going
				while(dep < len) {
					int c = seq[len-dep-1];
					if(c > 3) {
						top = bot = 0;
					} else {
						if(bloc.valid()) {
							bwops_ += 2;
							top = ebwt.mapLF(tloc, c);
							bot = ebwt.mapLF(bloc, c);
						} else {
							bwops_++;
							top = ebwt.mapLF1(top, tloc, c);
							if(top == OFF_MASK) {
								top = bot = 0;
							} else {
								bot = top+1;
							}
						}
					}
					if(bot <= top) {
						nedit++;
						if(nedit >= mineMax) {
							if(fw) { mineFw = nedit; } else { mineRc = nedit; }
							done = true;
						}
						break;
					}
					INIT_LOCS(top, bot, tloc, bloc, ebwt);
					dep++;
				}
				if(done) {
					break;
				}
				if(dep == len) {
					// Set the minimum # edits
					if(fw) { mineFw = nedit; } else { mineRc = nedit; }
					// Done
					if(nedit == 0 && bot > top) {
						if(repex) {
							// This is an exact hit
							int64_t score = len * sc.match();
							if(fw) {
								hits.addExactEeFw(top, bot, NULL, NULL, fw, score);
								assert(ebwt.contains(seq, NULL, NULL));
							} else {
								hits.addExactEeRc(top, bot, NULL, NULL, fw, score);
								assert(ebwt.contains(seq, NULL, NULL));
							}
						}
						nelt += (bot - top);
					}
					break;
				}
				dep++;
			}
		}
		return nelt;
	}
}
