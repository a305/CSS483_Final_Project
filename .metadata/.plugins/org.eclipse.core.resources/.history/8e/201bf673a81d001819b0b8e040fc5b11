package com.uwb.bt2j.aligner;

public class Read {
	public Read() {
		reset();
	}
	
	public Read(String nm, String seq, String ql) {
		init(nm, seq, ql);
	}
	
	public void reset() {
		rdid = 0;
		trimmed5 = trimmed3 = 0;
		readOrigBuf.clear();
		patFw.clear();
		patRc.clear();
		qual.clear();
		patFwRev.clear();
		patRcRev.clear();
		qualRev.clear();
		name.clear();
		filter = '?';
		seed = 0;
		parsed = false;
		ns_ = 0;
	}
	
	public void finalize() {
		for(int i = 0; i < patFw.length(); i++) {
			if((int)patFw[i] > 3) {
				ns_++;
			}
		}
		constructRevComps();
		constructReverses();
	}
	
	public void init(String nm, String seq, String ql) {
		reset();
		patFw.installChars(seq);
		qual.install(ql);
		for(int i = 0; i < patFw.length(); i++) {
			if((int)patFw[i] > 3) {
				ns_++;
			}
		}
		constructRevComps();
		constructReverses();
		if(nm != null) name.install(nm);
	}
	
	public boolean empty() {
		return patFw.empty();
	}
	
	public int length() {
		return patFw.length();
	}
	
	public int ns() {
		return ns_;
	}
	
	public void constructRevComps() {
		patRc.installReverseComp(patFw);
	}
	
	public void constructReverses() {
		patFwRev.installReverse(patFw);
		patRcRev.installReverse(patRc);
		qualRev.installReverse(qual);
	}
	
	public void fixMateName(int i) {
		int namelen = name.length();
		boolean append = false;
		if(namelen < 2) {
			// Name is too short to possibly have /1 or /2 on the end
			append = true;
		} else {
			if(i == 1) {
				// append = true iff mate name does not already end in /1
				append =
					name[namelen-2] != '/' ||
					name[namelen-1] != '1';
			} else {
				// append = true iff mate name does not already end in /2
				append =
					name[namelen-2] != '/' ||
					name[namelen-1] != '2';
			}
		}
		if(append) {
			name.append('/');
			name.append("012".charAt(i));
		}
	}
}
