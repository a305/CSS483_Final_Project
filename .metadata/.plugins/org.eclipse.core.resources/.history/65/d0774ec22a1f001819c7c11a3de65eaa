package com.uwb.bt2j.indexer;

import java.io.File;
import java.io.FileInputStream;
import java.io.OutputStream;
import java.io.PrintStream;

import com.uwb.bt2j.aligner.RandomSource;
import com.uwb.bt2j.util.IndexTypes;
import com.uwb.bt2j.util.RefReadInParams;
import com.uwb.bt2j.util.RefRecord;
import com.uwb.bt2j.util.file.FileBuf;
import com.uwb.bt2j.util.strings.BTDnaString;
import com.uwb.bt2j.util.types.EList;

public class Ebwt <TStr>{
	public static final String gEbwt_ext = "bt2";
	public String gLastIOErrMsg;
	boolean       _toBigEndian;
	int    _overrideOffRate;
	boolean       _verbose;
	boolean       _passMemExc;
	boolean       _sanity;
	boolean       fw_;     // true iff this is a forward index
	File       _in1;    // input fd for primary index file
	File       _in2;    // input fd for secondary index file
	String     _in1Str; // filename for primary index file
	String     _in2Str; // filename for secondary index file
	String     _inSaStr;  // filename for suffix-array file
	String     _inBwtStr; // filename for BWT file
	long  _zOff;
	long  _zEbwtByteOff;
	long   _zEbwtBpOff; 
	long  _nPat;  /// number of reference texts
	long  _nFrag; /// number of fragments
	
	APtrWrap<long> _plen;
	APtrWrap<long> _rstarts; // starting offset of fragments / text indexes
	// _fchr, _ftab and _eftab are expected to be relatively small
	// (usually < 1MB, perhaps a few MB if _fchr is particularly large
	// - like, say, 11).  For this reason, we don't bother with writing
	// them to disk through separate output streams; we
	APtrWrap<long> _fchr;
	APtrWrap<long> _ftab;
	APtrWrap<long> _eftab; // "extended" entries for _ftab
	// _offs may be extremely large.  E.g. for DNA w/ offRate=4 (one
	// offset every 16 rows), the total size of _offs is the same as
	// the total size of the input sequence
	APtrWrap<long> _offs;
	// _ebwt is the Extended Burrows-Wheeler Transform itself, and thus
	// is at least as large as the input sequence.
	APtrWrap<uint8_t> _ebwt;
	
	boolean       _useMm;        /// use memory-mapped files to hold the index
	boolean       useShmem_;     /// use shared memory to hold large parts of the index
	EList<String> _refnames; /// names of the reference sequences
	String mmFile1_;
	String mmFile2_;
	EbwtParams _eh;
	boolean packed_;

	static long default_bmax = IndexTypes.OFF_MASK;
	static long default_bmaxMultSqrt = IndexTypes.OFF_MASK;
	static long default_bmaxDivN = 4;
	static int      default_dcv = 1024;
	static boolean     default_noDc = false;
	static boolean     default_useBlockwise = true;
	static int default_seed = 0;
	static int      default_lineRate = 6;
	static int      default_offRate = 5;
	static int      default_offRatePlus = 0;
	static int      default_ftabChars = 10;
	static boolean     default_bigEndian = false;
	
	public enum EbwtFlags {
		EBWT_COLOR(2),
		EBWT_ENTIRE_REV(4);
		private int x;
		EbwtFlags(int y){x = y;}
	}
	
	public void Ebwt_INITS() {
		
	}
	
	public Ebwt(
			 int color,
			 int needEntireReverse,
		     boolean fw,
		     int overrideOffRate, // = -1,
		     int offRatePlus, // = -1,
		     boolean useMm, // = false,
		     boolean useShmem, // = false,
		     boolean mmSweep, // = false,
		     boolean loadNames, // = false,
			 boolean loadSASamp, // = true,
			 boolean loadFtab, // = true,
			 boolean loadRstarts, // = true,
		     boolean verbose, // = false,
		     boolean startVerbose, // = false,
		     boolean passMemExc, // = false,
		     boolean sanityCheck) {
		Ebwt_INITS();
		packed_ = false;
		_useMm = useMm;
		useShmem_ = useShmem;
		_in1Str = in + ".1." + gEbwt_ext;
		_in2Str = in + ".2." + gEbwt_ext;
		readIntoMemory(
			color,       // expect index to be colorspace?
			fw ? -1 : needEntireReverse, // need REF_READ_REVERSE
			loadSASamp,  // load the SA sample portion?
			loadFtab,    // load the ftab & eftab?
			loadRstarts, // load the rstarts array?
			true,        // stop after loading the header portion?
			_eh,        // params
			mmSweep,     // mmSweep
			loadNames,   // loadNames
			startVerbose); // startVerbose
		// If the offRate has been overridden, reflect that in the
		// _eh._offRate field
		if(offRatePlus > 0 && _overrideOffRate == -1) {
			_overrideOffRate = _eh._offRate + offRatePlus;
		}
		if(_overrideOffRate > _eh._offRate) {
			_eh.setOffRate(_overrideOffRate);
		}
	}
	
	public Ebwt(TStr exampleStr,
			boolean packed,
			int color,
			int needEntireReverse,
			int lineRate,
			int offRate,
			int ftabChars,
	        int nthreads,
			String file,   // base filename for EBWT files
			boolean fw,
			boolean useBlockwise,
			long bmax,
			long bmaxSqrtMult,
			long bmaxDivN,
			int dcv,
			EList<FileBuf> is,
			EList<RefRecord> szs,
			long sztot,
			RefReadInParams refparams,
			int seed,
			int overrideOffRate,
			boolean doSaFile,
			boolean doBwtFile,
			boolean verbose,
			boolean passMemExc,
			boolean sanityCheck) {
		_eh(
				joinedLen(szs),
				lineRate,
				offRate,
				ftabChars,
				color,
				refparams.reverse == REF_READ_REVERSE);
		Ebwt_INITS();
		_in1Str = file + ".1." + gEbwt_ext;
		_in2Str = file + ".2." + gEbwt_ext;
		packed_ = packed;
		// Open output files
		ofstream fout1(_in1Str.c_str(), ios::binary);
		if(!fout1.good()) {
			cerr << "Could not open index file for writing: \"" << _in1Str.c_str() << "\"" << endl
			     << "Please make sure the directory exists and that permissions allow writing by" << endl
			     << "Bowtie." << endl;
			throw 1;
		}
		ofstream fout2(_in2Str.c_str(), ios::binary);
		if(!fout2.good()) {
			cerr << "Could not open index file for writing: \"" << _in2Str.c_str() << "\"" << endl
			     << "Please make sure the directory exists and that permissions allow writing by" << endl
			     << "Bowtie." << endl;
			throw 1;
		}
		_inSaStr = file + ".sa";
		_inBwtStr = file + ".bwt";
		ofstream *saOut = NULL, *bwtOut = NULL;
		if(doSaFile) {
			saOut = new ofstream(_inSaStr.c_str(), ios::binary);
			if(!saOut->good()) {
				cerr << "Could not open suffix-array file for writing: \"" << _inSaStr.c_str() << "\"" << endl
			         << "Please make sure the directory exists and that permissions allow writing by" << endl
			         << "Bowtie." << endl;
				throw 1;
			}
		}
		if(doBwtFile) {
			bwtOut = new ofstream(_inBwtStr.c_str(), ios::binary);
			if(!bwtOut->good()) {
				cerr << "Could not open suffix-array file for writing: \"" << _inBwtStr.c_str() << "\"" << endl
			         << "Please make sure the directory exists and that permissions allow writing by" << endl
			         << "Bowtie." << endl;
				throw 1;
			}
		}
		// Build SA(T) and BWT(T) block by block
		initFromVector<TStr>(
			is,
		    szs,
		    sztot,
		    refparams,
		    fout1,
		    fout2,
                             file,
			saOut,
			bwtOut,
            nthreads,
		    useBlockwise,
		    bmax,
		    bmaxSqrtMult,
		    bmaxDivN,
		    dcv,
		    seed,
		    verbose);
		// Close output files
		fout1.flush();
		
		int64_t tellpSz1 = (int64_t)fout1.tellp();
		VMSG_NL("Wrote " << fout1.tellp() << " bytes to primary EBWT file: " << _in1Str.c_str());
		fout1.close();
		bool err = false;
		if(tellpSz1 > fileSize(_in1Str.c_str())) {
			err = true;
			cerr << "Index is corrupt: File size for " << _in1Str.c_str() << " should have been " << tellpSz1
			     << " but is actually " << fileSize(_in1Str.c_str()) << "." << endl;
		}
		fout2.flush();
		
		int64_t tellpSz2 = (int64_t)fout2.tellp();
		VMSG_NL("Wrote " << fout2.tellp() << " bytes to secondary EBWT file: " << _in2Str.c_str());
		fout2.close();
		if(tellpSz2 > fileSize(_in2Str.c_str())) {
			err = true;
			cerr << "Index is corrupt: File size for " << _in2Str.c_str() << " should have been " << tellpSz2
			     << " but is actually " << fileSize(_in2Str.c_str()) << "." << endl;
		}
		
		if(saOut != NULL) {
			// Check on suffix array output file size
			int64_t tellpSzSa = (int64_t)saOut->tellp();
			VMSG_NL("Wrote " << tellpSzSa << " bytes to suffix-array file: " << _inSaStr.c_str());
			saOut->close();
			if(tellpSzSa > fileSize(_inSaStr.c_str())) {
				err = true;
				cerr << "Index is corrupt: File size for " << _inSaStr.c_str() << " should have been " << tellpSzSa
					 << " but is actually " << fileSize(_inSaStr.c_str()) << "." << endl;
			}
		}

		if(bwtOut != NULL) {
			// Check on suffix array output file size
			int64_t tellpSzBwt = (int64_t)bwtOut->tellp();
			VMSG_NL("Wrote " << tellpSzBwt << " bytes to BWT file: " << _inBwtStr.c_str());
			bwtOut->close();
			if(tellpSzBwt > fileSize(_inBwtStr.c_str())) {
				err = true;
				cerr << "Index is corrupt: File size for " << _inBwtStr.c_str() << " should have been " << tellpSzBwt
					 << " but is actually " << fileSize(_inBwtStr.c_str()) << "." << endl;
			}
		}
		
		if(err) {
			cerr << "Please check if there is a problem with the disk or if disk is full." << endl;
			throw 1;
		}
		
		// Reopen as input streams
		VMSG_NL("Re-opening _in1 and _in2 as input streams");
		if(_sanity) {
			VMSG_NL("Sanity-checking Bt2");
			assert(!isInMemory());
			readIntoMemory(
				color,                       // colorspace?
				fw ? -1 : needEntireReverse, // 1 -> need the reverse to be reverse-of-concat
				true,                        // load SA sample (_offs[])?
				true,                        // load ftab (_ftab[] & _eftab[])?
				true,                        // load r-starts (_rstarts[])?
				false,                       // just load header?
				NULL,                        // Params object to fill
				false,                       // mm sweep?
				true,                        // load names?
				false);                      // verbose startup?
			sanityCheckAll(refparams.reverse);
			evictFromMemory();
			assert(!isInMemory());
		}
		VMSG_NL("Returning from Ebwt constructor");
	}
  
	public String adjustEbwtBase(String cmdline, String ebwtFileBase, boolean verbose) {
		String str = ebwtFileBase;
		File in = new File((str + ".1." + gEbwt_ext));
		
		if(verbose) System.out.println( "Trying " + str);
		if(!in.exists())
			if(verbose) System.out.println( "  didn't work" );
			if(System.getenv("BOWTIE2_INDEXES") != null) {
				str = System.getenv("BOWTIE2_INDEXES") + "/" + ebwtFileBase;
				if(verbose) System.out.println( "Trying " + str);
				in=new File((str + ".1." + gEbwt_ext));
			}
		if(!in.exists()) {
			System.err.println("Could not locate a Bowtie index corresponding to basename \"" + ebwtFileBase + "\"" );
		}
		return str;
	}
	
	public TStr join(EList<TStr> l, int seed) {
		RandomSource rand; // reproducible given same seed
		rand.init(seed);
		TStr ret;
		long guessLen = 0;
		for(long i = 0; i < l.size(); i++) {
			guessLen += length(l[i]);
		}
		ret.resize(guessLen);
		long off = 0;
		for(int i = 0; i < l.size(); i++) {
			TStr s = l[i];
			for(int j = 0; j < s.size(); j++) {
				ret.set(s.get(j), off++);
			}
		}
		return ret;
	}
	public TStr join(
			EList<FileBuf> l,
            EList<RefRecord> szs,
            long sztot,
            RefReadInParams refparams,
            int seed) {
		RandomSource rand; // reproducible given same seed
		rand.init(seed);
		RefReadInParams rpcp = refparams;
		TStr ret;
		long guessLen = sztot;
		ret.resize(guessLen);
		long dstoff = 0;
		for(int i = 0; i < l.size(); i++) {
			// For each sequence we can pull out of istream l[i]...
			boolean first = true;
			while(!l.get(i).eof()) {
				RefRecord rec = fastaRefReadAppend(l.get(i), first, ret, dstoff, rpcp);
				first = false;
				long bases = rec.len;
				if(bases == 0) continue;
			}
		}
		return ret;
	}
	
	public void joinToDisk(
			EList<FileBuf> l,
			EList<RefRecord> szs,
			long sztot,
			RefReadInParams refparams,
			TStr ret,
			OutputStream out1,
			OutputStream out2
			) {
		RefReadInParams rpcp = refparams;
		// Not every fragment represents a distinct sequence - many
		// fragments may correspond to a single sequence.  Count the
		// number of sequences here by counting the number of "first"
		// fragments.
		this._nPat = 0;
		this._nFrag = 0;
		for(int i = 0; i < szs.size(); i++) {
			if(szs.get(i).len > 0) this._nFrag++;
			if(szs.get(i).first && szs.get(i).len > 0) this._nPat++;
		}
		_rstarts.reset();
		writeU<Long>(out1, this._nPat, this.toBe());
		// Allocate plen[]
		try {
			this._plen.init(new long[this._nPat], this._nPat);
		} catch(bad_alloc& e) {
			cerr << "Out of memory allocating plen[] in Ebwt::join()"
			     << " at " << __FILE__ << ":" << __LINE__ << endl;
			throw e;
		}
		// For each pattern, set plen
		TIndexOff npat = -1;
		for(long i = 0; i < szs.size(); i++) {
			if(szs.get(i).first && szs.get(i).len > 0) {
				if(npat >= 0) {
					writeU<Long>(out1, this.plen()[npat], this.toBe());
				}
				this.plen()[++npat] = (szs.get(i).len + szs.get(i).off);
			} else {
				// edge case, but we could get here with npat == -1
				// e.g. when building from a reference of all Ns
				if (npat < 0) npat = 0;
				this.plen()[npat] += (szs.get(i).len + szs.get(i).off);
			}
		}
		writeU<long>(out1, this.plen()[npat], this.toBe());
		// Write the number of fragments
		writeU<long>(out1, this._nFrag, this.toBe());
		long seqsRead = 0;
		long dstoff = 0;
		// For each filebuf
		for(int i = 0; i < l.size(); i++) {
			boolean first = true;
			long patoff = 0;
			// For each *fragment* (not necessary an entire sequence) we
			// can pull out of istream l[i]...
			while(!l.get(i).eof()) {
				String name;
				// Push a new name onto our vector
				_refnames.push_back("");
				RefRecord rec = fastaRefReadAppend(
					l.get(i), first, ret, dstoff, rpcp, _refnames.back());
				first = false;
				long bases = rec.len;
				if(rec.first && rec.len > 0) {
					if(_refnames.back().length() == 0) {
						// If name was empty, replace with an index
						OutputStream stm;
						stm.write(seqsRead);
						_refnames.back() = stm.str();
					}
				} else {
					// This record didn't actually start a new sequence so
					// no need to add a name
					//assert_eq(0, _refnames.back().length());
					_refnames.pop_back();
				}
				// Increment seqsRead if this is the first fragment
				if(rec.first && rec.len > 0) seqsRead++;
				if(bases == 0) continue;
				assert_leq(bases, this.plen()[seqsRead-1]);
				// Reset the patoff if this is the first fragment
				if(rec.first) patoff = 0;
				patoff += rec.off; // add fragment's offset from end of last frag.
				// Adjust rpcps
				//uint32_t seq = seqsRead-1;
				// This is where rstarts elements are written to the output stream
				//writeU32(out1, oldRetLen, this.toBe()); // offset from beginning of joined string
				//writeU32(out1, seq,       this.toBe()); // sequence id
				//writeU32(out1, patoff,    this.toBe()); // offset into sequence
				patoff += bases;
			}
			l.get(i).reset();
		}
	}
	
	public void buildToDisk(
			InorderBlockwiseSA<TStr> sa,
			TStr s,
			OutputStream out1,
			OutputStream out2,
			OutputStream saOut,
			OutputStream bwtOut
			) {
		EbwtParams& eh = this->_eh;

		assert(eh.repOk());
		assert_eq(s.length()+1, sa.size());
		assert_eq(s.length(), eh._len);
		assert_gt(eh._lineRate, 3);
		assert(sa.suffixItrIsReset());

		long len = eh._len;
		long ftabLen = eh._ftabLen;
		long sideSz = eh._sideSz;
		long ebwtTotSz = eh._ebwtTotSz;
		long fchr[] = {0, 0, 0, 0, 0};
		EList<long> ftab(EBWT_CAT);
		long zOff = OFF_MASK;

		// Save # of occurrences of each character as we walk along the bwt
		long occ[4] = {0, 0, 0, 0};
		long occSave[4] = {0, 0, 0, 0};

		// Record rows that should "absorb" adjacent rows in the ftab.
		// The absorbed rows represent suffixes shorter than the ftabChars
		// cutoff.
		uint8_t absorbCnt = 0;
		EList<uint8_t> absorbFtab(EBWT_CAT);
		try {
			VMSG_NL("Allocating ftab, absorbFtab");
			ftab.resize(ftabLen);
			ftab.fillZero();
			absorbFtab.resize(ftabLen);
			absorbFtab.fillZero();
		} catch(bad_alloc &e) {
			cerr << "Out of memory allocating ftab[] or absorbFtab[] "
			     << "in Ebwt::buildToDisk() at " << __FILE__ << ":"
			     << __LINE__ << endl;
			throw e;
		}

		// Allocate the side buffer; holds a single side as its being
		// constructed and then written to disk.  Reused across all sides.
	#ifdef SIXTY4_FORMAT
		EList<uint64_t> ebwtSide(EBWT_CAT);
	#else
		EList<uint8_t> ebwtSide(EBWT_CAT);
	#endif
		try {
	#ifdef SIXTY4_FORMAT
			ebwtSide.resize(sideSz >> 3);
	#else
			ebwtSide.resize(sideSz);
	#endif
		} catch(bad_alloc &e) {
			cerr << "Out of memory allocating ebwtSide[] in "
			     << "Ebwt::buildToDisk() at " << __FILE__ << ":"
			     << __LINE__ << endl;
			throw e;
		}

		// Points to the base offset within ebwt for the side currently
		// being written
		long side = 0;

		// Whether we're assembling a forward or a reverse bucket
		bool fw;
		TIndexOff sideCur = 0;
		fw = true;

		// Have we skipped the '$' in the last column yet?
		ASSERT_ONLY(bool dollarSkipped = false);

		long si = 0;   // string offset (chars)
		ASSERT_ONLY(long lastSufInt = 0);
		ASSERT_ONLY(bool inSA = true); // true iff saI still points inside suffix
		                               // array (as opposed to the padding at the
		                               // end)
		// Iterate over packed bwt bytes
		VMSG_NL("Entering Ebwt loop");
		ASSERT_ONLY(long beforeEbwtOff = (long)out1.tellp()); // @double-check - pos_type, std::streampos 
		
		// First integer in the suffix-array output file is the length of the
		// array, including $
		if(saOut != NULL) {
			// Write length word
			writeU<long>(*saOut, len+1, this->toBe());
		}
		
		// First integer in the BWT output file is the length of BWT(T), including $
		if(bwtOut != NULL) {
			// Write length word
			writeU<long>(*bwtOut, len+1, this->toBe());
		}
		
		while(side < ebwtTotSz) {
			// Sanity-check our cursor into the side buffer
			assert_geq(sideCur, 0);
			assert_lt(sideCur, (int)eh._sideBwtSz);
			assert_eq(0, side % sideSz); // 'side' must be on side boundary
			ebwtSide[sideCur] = 0; // clear
			assert_lt(side + sideCur, ebwtTotSz);
			// Iterate over bit-pairs in the si'th character of the BWT
	#ifdef SIXTY4_FORMAT
			for(int bpi = 0; bpi < 32; bpi++, si++)
	#else
			for(int bpi = 0; bpi < 4; bpi++, si++)
	#endif
			{
				int bwtChar;
				bool count = true;
				if(si <= len) {
					// Still in the SA; extract the bwtChar
					long saElt = sa.nextSuffix();
					// Write it to the optional suffix-array output file
					if(saOut != NULL) {
						writeU<long>(*saOut, saElt, this->toBe());
					}
					// TODO: what exactly to write to the BWT output file?  How to
					// represent $?  How to pack nucleotides into bytes/words?
					
					// (that might have triggered sa to calc next suf block)
					if(saElt == 0) {
						// Don't add the '$' in the last column to the BWT
						// transform; we can't encode a $ (only A C T or G)
						// and counting it as, say, an A, will mess up the
						// LR mapping
						bwtChar = 0; count = false;
						ASSERT_ONLY(dollarSkipped = true);
						zOff = si; // remember the SA row that
						           // corresponds to the 0th suffix
					} else {
						bwtChar = (int)(s[saElt-1]);
						assert_lt(bwtChar, 4);
						// Update the fchr
						fchr[bwtChar]++;
					}
					// Update ftab
					if((len-saElt) >= (long)eh._ftabChars) {
						// Turn the first ftabChars characters of the
						// suffix into an integer index into ftab.  The
						// leftmost (lowest index) character of the suffix
						// goes in the most significant bit pair if the
						// integer.
						long sufInt = 0;
						for(int i = 0; i < eh._ftabChars; i++) {
							sufInt <<= 2;
							assert_lt((long)i, len-saElt);
							sufInt |= (unsigned char)(s[saElt+i]);
						}
						// Assert that this prefix-of-suffix is greater
						// than or equal to the last one (true b/c the
						// suffix array is sorted)
						#ifndef NDEBUG
						if(lastSufInt > 0) assert_geq(sufInt, lastSufInt);
						lastSufInt = sufInt;
						#endif
						// Update ftab
						assert_lt(sufInt+1, ftabLen);
						ftab[sufInt+1]++;
						if(absorbCnt > 0) {
							// Absorb all short suffixes since the last
							// transition into this transition
							absorbFtab[sufInt] = absorbCnt;
							absorbCnt = 0;
						}
					} else {
						// Otherwise if suffix is fewer than ftabChars
						// characters long, then add it to the 'absorbCnt';
						// it will be absorbed into the next transition
						assert_lt(absorbCnt, 255);
						absorbCnt++;
					}
					// Suffix array offset boundary? - update offset array
					if((si & eh._offMask) == si) {
						assert_lt((si >> eh._offRate), eh._offsLen);
						// Write offsets directly to the secondary output
						// stream, thereby avoiding keeping them in memory
						writeU<long>(out2, saElt, this->toBe());
					}
				} else {
					// Strayed off the end of the SA, now we're just
					// padding out a bucket
					#ifndef NDEBUG
					if(inSA) {
						// Assert that we wrote all the characters in the
						// string before now
						assert_eq(si, len+1);
						inSA = false;
					}
					#endif
					// 'A' used for padding; important that padding be
					// counted in the occ[] array
					bwtChar = 0;
				}
				if(count) occ[bwtChar]++;
				// Append BWT char to bwt section of current side
				if(fw) {
					// Forward bucket: fill from least to most
	#ifdef SIXTY4_FORMAT
					ebwtSide[sideCur] |= ((uint64_t)bwtChar << (bpi << 1));
					if(bwtChar > 0) assert_gt(ebwtSide[sideCur], 0);
	#else
					pack_2b_in_8b(bwtChar, ebwtSide[sideCur], bpi);
					assert_eq((ebwtSide[sideCur] >> (bpi*2)) & 3, bwtChar);
	#endif
				} else {
					// Backward bucket: fill from most to least
	#ifdef SIXTY4_FORMAT
					ebwtSide[sideCur] |= ((uint64_t)bwtChar << ((31 - bpi) << 1));
					if(bwtChar > 0) assert_gt(ebwtSide[sideCur], 0);
	#else
					pack_2b_in_8b(bwtChar, ebwtSide[sideCur], 3-bpi);
					assert_eq((ebwtSide[sideCur] >> ((3-bpi)*2)) & 3, bwtChar);
	#endif
				}
			} // end loop over bit-pairs
			assert_eq(dollarSkipped ? 3 : 0, (occ[0] + occ[1] + occ[2] + occ[3]) & 3);
	#ifdef SIXTY4_FORMAT
			assert_eq(0, si & 31);
	#else
			assert_eq(0, si & 3);
	#endif

			sideCur++;
			if(sideCur == (int)eh._sideBwtSz) {
				sideCur = 0;
				long *cpptr = reinterpret_cast<long*>(ebwtSide.ptr());
				// Write 'A', 'C', 'G' and 'T' tallies
				side += sideSz;
				assert_leq(side, eh._ebwtTotSz);
	#ifdef BOWTIE_64BIT_INDEX
				cpptr[(sideSz >> 3)-4] = endianizeU<long>(occSave[0], this->toBe());
				cpptr[(sideSz >> 3)-3] = endianizeU<long>(occSave[1], this->toBe());
				cpptr[(sideSz >> 3)-2] = endianizeU<long>(occSave[2], this->toBe());
				cpptr[(sideSz >> 3)-1] = endianizeU<long>(occSave[3], this->toBe());
	#else
				cpptr[(sideSz >> 2)-4] = endianizeU<long>(occSave[0], this->toBe());
				cpptr[(sideSz >> 2)-3] = endianizeU<long>(occSave[1], this->toBe());
				cpptr[(sideSz >> 2)-2] = endianizeU<long>(occSave[2], this->toBe());
				cpptr[(sideSz >> 2)-1] = endianizeU<long>(occSave[3], this->toBe());
	#endif
				occSave[0] = occ[0];
				occSave[1] = occ[1];
				occSave[2] = occ[2];
				occSave[3] = occ[3];
				// Write backward side to primary file
				out1.write((char *)ebwtSide.ptr(), sideSz);
			}
		}
		VMSG_NL("Exited Ebwt loop");
		assert_neq(zOff, OFF_MASK);
		if(absorbCnt > 0) {
			// Absorb any trailing, as-yet-unabsorbed short suffixes into
			// the last element of ftab
			absorbFtab[ftabLen-1] = absorbCnt;
		}
		// Assert that our loop counter got incremented right to the end
		assert_eq(side, eh._ebwtTotSz);
		// Assert that we wrote the expected amount to out1
		assert_eq(((long)out1.tellp() - beforeEbwtOff), eh._ebwtTotSz); // @double-check - pos_type
		// assert that the last thing we did was write a forward bucket

		//
		// Write zOff to primary stream
		//
		writeU<long>(out1, zOff, this->toBe());

		//
		// Finish building fchr
		//
		// Exclusive prefix sum on fchr
		for(int i = 1; i < 4; i++) {
			fchr[i] += fchr[i-1];
		}
		assert_eq(fchr[3], len);
		// Shift everybody up by one
		for(int i = 4; i >= 1; i--) {
			fchr[i] = fchr[i-1];
		}
		fchr[0] = 0;
		if(_verbose) {
			for(int i = 0; i < 5; i++)
				cout << "fchr[" << "ACGT$"[i] << "]: " << fchr[i] << endl;
		}
		// Write fchr to primary file
		for(int i = 0; i < 5; i++) {
			writeU<long>(out1, fchr[i], this->toBe());
		}

		//
		// Finish building ftab and build eftab
		//
		// Prefix sum on ftable
		long eftabLen = 0;
		assert_eq(0, absorbFtab[0]);
		for(long i = 1; i < ftabLen; i++) {
			if(absorbFtab[i] > 0) eftabLen += 2;
		}
		assert_leq(eftabLen, (long)eh._ftabChars*2);
		eftabLen = eh._ftabChars*2;
		EList<long> eftab(EBWT_CAT);
		try {
			eftab.resize(eftabLen);
			eftab.fillZero();
		} catch(bad_alloc &e) {
			cerr << "Out of memory allocating eftab[] "
			     << "in Ebwt::buildToDisk() at " << __FILE__ << ":"
			     << __LINE__ << endl;
			throw e;
		}
		long eftabCur = 0;
		for(long i = 1; i < ftabLen; i++) {
			long lo = ftab[i] + Ebwt::ftabHi(ftab.ptr(), eftab.ptr(), len, ftabLen, eftabLen, i-1);
			if(absorbFtab[i] > 0) {
				// Skip a number of short pattern indicated by absorbFtab[i]
				long hi = lo + absorbFtab[i];
				assert_lt(eftabCur*2+1, eftabLen);
				eftab[eftabCur*2] = lo;
				eftab[eftabCur*2+1] = hi;
				ftab[i] = (eftabCur++) ^ OFF_MASK; // insert pointer into eftab
				assert_eq(lo, Ebwt::ftabLo(ftab.ptr(), eftab.ptr(), len, ftabLen, eftabLen, i));
				assert_eq(hi, Ebwt::ftabHi(ftab.ptr(), eftab.ptr(), len, ftabLen, eftabLen, i));
			} else {
				ftab[i] = lo;
			}
		}
		assert_eq(Ebwt::ftabHi(ftab.ptr(), eftab.ptr(), len, ftabLen, eftabLen, ftabLen-1), len+1);
		// Write ftab to primary file
		for(long i = 0; i < ftabLen; i++) {
			writeU<long>(out1, ftab[i], this->toBe());
		}
		// Write eftab to primary file
		for(long i = 0; i < eftabLen; i++) {
			writeU<long>(out1, eftab[i], this->toBe());
		}

		// Note: if you'd like to sanity-check the Ebwt, you'll have to
		// read it back into memory first!
		assert(!isInMemory());
		VMSG_NL("Exiting Ebwt::buildToDisk()");
	}
	
	public void joinedToTextOff(
			long qlen, 
			long off,
			long tidx,
			long textoff,
			long tlen,
			boolean rejectStraddle,
			boolean straddled){
		long top = 0;
		long bot = _nFrag; // 1 greater than largest addressable element
		long elt = IndexTypes.OFF_MASK;
		// Begin binary search
		while(true) {
			elt = top + ((bot - top) >> 1);
			long lower = rstarts()[elt*3];
			long upper;
			if(elt == _nFrag-1) {
				upper = _eh._len;
			} else {
				upper = rstarts()[((elt+1)*3)];
			}
			long fraglen = upper - lower;
			if(lower <= off) {
				if(upper > off) { // not last element, but it's within
					// off is in this range; check if it falls off
					if(off + qlen > upper) {
						straddled = true;
						if(rejectStraddle) {
							// it falls off; signal no-go and return
							tidx = IndexTypes.OFF_MASK;
							return;
						}
					}
					// This is the correct text idx whether the index is
					// forward or reverse
					tidx = rstarts()[(elt*3)+1];
					// it doesn't fall off; now calculate textoff.
					// Initially it's the number of characters that precede
					// the alignment in the fragment
					long fragoff = off - rstarts()[(elt*3)];
					if(!this.fw_) {
						fragoff = fraglen - fragoff - 1;
						fragoff -= (qlen-1);
					}
					// Add the alignment's offset into the fragment
					// ('fragoff') to the fragment's offset within the text
					textoff = fragoff + rstarts()[(elt*3)+2];
					break; // done with binary search
				} else {
					// 'off' belongs somewhere in the region between elt
					// and bot
					top = elt;
				}
			} else {
				// 'off' belongs somewhere in the region between top and
				// elt
				bot = elt;
			}
			// continue with binary search
		}
		tlen = this.plen()[tidx];
	}
	
	public long walkLeft(long row, long steps) {
		SideLocus l;
		if(steps > 0) l.initFromRow(row, _eh, ebwt());
		while(steps > 0) {
			if(row == _zOff) return IndexTypes.OFF_MASK;
			long newrow = this.mapLF(l);
			row = newrow;
			steps--;
			if(steps > 0) l.initFromRow(row, _eh, ebwt());
		}
		return row;
	}
	
	public long getOffset(long row) {
		if(row == _zOff) return 0;
		if((row & _eh._offMask) == row) return this.offs()[row >> _eh._offRate];
		long jumps = 0;
		SideLocus l;
		l.initFromRow(row, _eh, ebwt());
		while(true) {
			long newrow = this.mapLF(l);
			jumps++;
			row = newrow;
			if(row == _zOff) {
				return jumps;
			} else if((row & _eh._offMask) == row) {
				return jumps + this.offs()[row >> _eh._offRate];
			}
			l.initFromRow(row, _eh, ebwt());
		}
	}
	
	public long getOffset(long elt, boolean fw, long hitlen) {
		long off = getOffset(elt);
		if(!fw) {
			off = _eh._len - off - 1;
			off -= (hitlen-1);
		}
		return off;
	}
	
	public boolean contains(BTDnaString str, long otop, long obot) {
		SideLocus tloc, bloc;
		if(str.empty()) {
			if(otop != null && obot != null) otop = obot = 0;
			return true;
		}
		int c = str[str.length()-1];
		long top = 0, bot = 0;
		if(c < 4) {
			top = fchr()[c];
			bot = fchr()[c+1];
		} else {
			boolean set = false;
			for(int i = 0; i < 4; i++) {
				if(fchr()[c] < fchr()[c+1]) {
					if(set) {
						return false;
					} else {
						set = true;
						top = fchr()[c];
						bot = fchr()[c+1];
					}
				}
			}
		}
		tloc.initFromRow(top, eh(), ebwt());
		bloc.initFromRow(bot, eh(), ebwt());
		for(long i = (long)str.length()-2; i >= 0; i--) {
			c = str[i];
			if(c <= 3) {
				top = mapLF(tloc, c);
				bot = mapLF(bloc, c);
			} else {
				long sz = bot - top;
				int c1 = mapLF1(top, tloc);
				bot = mapLF(bloc, c1);
				if(bot - top < sz) {
					// Encountered an N and could not proceed through it because
					// there was more than one possible nucleotide we could replace
					// it with
					return false;
				}
			}
			if(i > 0) {
				tloc.initFromRow(top, eh(), ebwt());
				bloc.initFromRow(bot, eh(), ebwt());
			}
		}
		if(otop != null && obot != null) {
			otop = top; obot = bot;
		}
		return bot > top;
	}
	
	public static long fileSize(String name) {
		File f = new File(name);
		return f.length();
	}
	
	public static int pop32(long x) {
		// Lots of cache misses on following lines (>10K)
		x = x - ((x >> 1) & 0x55555555);
		x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
		x = (x + (x >> 4)) & 0x0F0F0F0F;
		x = x + (x >> 8);
		x = x + (x >> 16);
		x = x + (x >> 32);
		return (int)(x & 0x3F);
	}
	
	public static int countInU64(int c, long dw) {
		long c_table[] = {
				0xffffffff,
				0xaaaaaaaa,
				0x55555555,
				0x00000000
		};
		long c0 = c_table[c];
		long x0 = dw ^ c0;
		long x1 = (x0 >> 1);
		long x2 = x1 & (0x55555555);
		long x3 = x0 & x2;
	    long tmp = pop32(x3);
		return (int) tmp;
	}
	
	public EbwtParams eh() {
		return _eh;
	}
	
	public boolean ftabLoHi(
			BTDnaString seq, // sequence to extract from
			int off,             // offset into seq to begin extracting
			boolean rev,               // reverse while extracting
			long top,
			long bot)
			) {
		long fi = ftabSeqToInt(seq, off, rev);
		if(fi == Long.MAX_VALUE) {
			return false;
		}
		top = ftabHi(fi);
		bot = ftabLo(fi+1);
		return true;
	}
			
	public static Pair<Ebwt, Ebwt> fromString(
			String str,
			boolean packed,
			int color,
			int reverse,
			boolean bigEndian,
			int lineRate,
			int offRate,
			int ftabChars,
			String file,
			boolean useBlockwise,
			long bmax,
			long bmaxSqrtMult,
			long bmaxDivN,
			int dcv,
			int seed,
			boolean verbose,
			boolean autoMem,
			boolean sanity){
		EList<String> strs = new EList(EBWT_CAT);
		strs.push_back(str);
		return fromStrings<TStr>(
			strs,
			packed,
			color,
			reverse,
			bigEndian,
			lineRate,
			offRate,
			ftabChars,
			file,
			useBlockwise,
			bmax,
			bmaxSqrtMult,
			bmaxDivN,
			dcv,
			seed,
			verbose,
			autoMem,
			sanity);
	}
	public static Pair<Ebwt, Ebwt> fromStrings(
			String strs,
			boolean packed,
			int color,
			int reverse,
			boolean bigEndian,
			int lineRate,
			int offRate,
			int ftabChars,
			String file,
			boolean useBlockwise,
			long bmax,
			long bmaxSqrtMult,
			long bmaxDivN,
			int dcv,
			int seed,
			boolean verbose,
			boolean autoMem,
			boolean sanity){
		EList<FileBuf> is = new EList(EBWT_CAT);
		RefReadInParams refparams = new RefReadInParams(color, REF_READ_FORWARD, false, false);
		String ss = "";
		for(long i = 0; i < strs.size(); i++) {
			ss += ">" + i + "\n" + strs[i] + "\n";
		}
		auto_ptr<FileBuf> fb(new FileBuf(ss.get()));
		is.push_back(fb.get());
		// Vector for the ordered list of "records" comprising the input
		// sequences.  A record represents a stretch of unambiguous
		// characters in one of the input sequences.
		EList<RefRecord> szs = new EList(EBWT_CAT);
		Pair<Long, Long> sztot;
		sztot = BitPairReference::szsFromFasta(is, file, bigEndian, refparams, szs, sanity);
		// Construct Ebwt from input strings and parameters
		Ebwt ebwtFw = new Ebwt(
			TStr,
			packed,
			refparams.color ? 1 : 0,
			-1,           // fw
			lineRate,
			offRate,      // suffix-array sampling rate
			ftabChars,    // number of chars in initial arrow-pair calc
			file,         // basename for .?.ebwt files
			true,         // fw?
			useBlockwise, // useBlockwise
			bmax,         // block size for blockwise SA builder
			bmaxSqrtMult, // block size as multiplier of sqrt(len)
			bmaxDivN,     // block size as divisor of len
			dcv,          // difference-cover period
			is,           // list of input streams
			szs,          // list of reference sizes
			sztot.first,  // total size of all unambiguous ref chars
			refparams,    // reference read-in parameters
			seed,         // pseudo-random number generator seed
			-1,           // override offRate
			verbose,      // be talkative
			autoMem,      // pass exceptions up to the toplevel so that we can adjust memory settings automatically
			sanity);      // verify results and internal consistency
		refparams.reverse = reverse;
		szs.clear();
		sztot = BitPairReference.szsFromFasta(is, file, bigEndian, refparams, szs, sanity);
		// Construct Ebwt from input strings and parameters
		Ebwt ebwtBw = new Ebwt(
			TStr(),
			packed,
			refparams.color ? 1 : 0,
			reverse == REF_READ_REVERSE,
			lineRate,
			offRate,      // suffix-array sampling rate
			ftabChars,    // number of chars in initial arrow-pair calc
			file + ".rev",// basename for .?.ebwt files
			false,        // fw?
			useBlockwise, // useBlockwise
			bmax,         // block size for blockwise SA builder
			bmaxSqrtMult, // block size as multiplier of sqrt(len)
			bmaxDivN,     // block size as divisor of len
			dcv,          // difference-cover period
			is,           // list of input streams
			szs,          // list of reference sizes
			sztot.first,  // total size of all unambiguous ref chars
			refparams,    // reference read-in parameters
			seed,         // pseudo-random number generator seed
			-1,           // override offRate
			verbose,      // be talkative
			autoMem,      // pass exceptions up to the toplevel so that we can adjust memory settings automatically
			sanity);      // verify results and internal consistency
		return new Pair(ebwtFw, ebwtBw);
	}
	
	public boolean isPacked() {
		return packed_;
	}
	
	public void szsToDisk(EList<RefRecord> szs, OutputStream os, int reverse) {
		
	}
	
	public void initFromVector(
			EList<FileBuf> is,
            EList<RefRecord> szs,
            long sztot,
            RefReadInParams refparams,
            FileOutputStream out1,
            FileOutputStream out2,
            String outfile,
            FileOutputStream saOut,
            FileOutputStream bwtOut,
            int nthreads,
            boolean useBlockwise,
            long bmax,
            long bmaxSqrtMult,
            long bmaxDivN,
            int dcv,
            int seed,
            boolean verbose){
		
	}
	
	public boolean is_read_err(int fdesc, int ret, int count) {
		if (ret < 0) {
			gLastIOErrMsg = "ERRNO: " + errno + " ERR Msg:" + strerror(errno) + "\n";
			return true;
		}
		return false;
	}
	
	public boolean is_fread_err(File file_hd, int ret, int count) {
		if(file_hd.canRead()) {
			gLastIOErrMsg = "Error Reading File!";
			return true;
		}
		return false;
	}
			
	public long fchr() {
		return _fchr.get();
	}
	
	public byte ebwt() {
		return _ebwt.get();
	}
	
	public long mapLF(SideLocus l) {
		long ret;
		int c = rowL(l);
		ret = countBt2Side(l, c);
		return ret;
	}
	
	public long mapLF1(long row, SideLocus l, int c) {
		if(rowL(l) != c || row == _zOff) return IndexTypes.OFF_MASK;
		long ret = countBt2Side(l, c);
		return ret;
	}
	
	private PrintStream log() {
		return System.out;
	}
	
	public boolean verbose() {
		return _verbose;
	}
	
	private void verbose(String s) {
		if(verbose()) {
			log().println(s);
			log().flush();
		}
	}
}
