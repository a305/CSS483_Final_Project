package com.uwb.bt2j.aligner;

public class SimpleFunc {
	public static final byte SIMPLE_FUNC_CONST = 1;
	public static final byte SIMPLE_FUNC_LINEAR = 2;
	public static final byte SIMPLE_FUNC_SQRT = 3;
	public static final byte SIMPLE_FUNC_LOG = 4;
	
	protected int type_;
	protected double I_, X_, C_, L_;
	
	public SimpleFunc() {
		type_ = 0;
		I_ = X_ = C_ = L_ = 0.0;
	}
	
	public SimpleFunc(int type, double I, double X, double C, double L) {
		init(type, I, X, C, L);
	}
	
	public void init(int type, double I, double X, double C, double L) {
		type_ = type; I_ = I; X_ = X; C_ = C; L_ = L;
	}
	
	public void init(int type, double C, double L) {
		type_ = type; C_ = C; L_ = L;
		I_ = -Double.MAX_VALUE;
		X_ = Double.MAX_VALUE;
	}
	
	public int parseType(String otype) {
		String type = otype;
		if(type == "C" || type == "Constant") {
			return SIMPLE_FUNC_CONST;
		} else if(type == "L" || type == "Linear") {
			return SIMPLE_FUNC_LINEAR;
		} else if(type == "S" || type == "Sqrt") {
			return SIMPLE_FUNC_SQRT;
		} else if(type == "G" || type == "Log") {
			return SIMPLE_FUNC_LOG;
		}
		System.err.println("Error: Bad function type '" + otype
				  + "'.  Should be C (constant), L (linear), "
				  + "S (square root) or G (natural log)." + "\n");
		return 0;
	}
	
	public SimpleFunc parse(String s, double defaultConst, double defaultLinear, double defaultMin, double defaultMax) {
		// Separate value into comma-separated tokens
		EList<String> ctoks(MISC_CAT);
		String ctok;
		istringstream css(s);
		SimpleFunc fv;
		while(getline(css, ctok, ',')) {
			ctoks.push_back(ctok);
		}
		if(ctoks.size() >= 1) {
			fv.setType(parseType(ctoks[0]));
		}
		if(ctoks.size() >= 2) {
			double co;
			istringstream tmpss(ctoks[1]);
			tmpss >> co;
			fv.setConst(co);
		} else {
			fv.setConst(defaultConst);
		}
		if(ctoks.size() >= 3) {
			double ce;
			istringstream tmpss(ctoks[2]);
			tmpss >> ce;
			fv.setCoeff(ce);
		} else {
			fv.setCoeff(defaultLinear);
		}
		if(ctoks.size() >= 4) {
			double mn;
			istringstream tmpss(ctoks[3]);
			tmpss >> mn;
			fv.setMin(mn);
		} else {
			fv.setMin(defaultMin);
		}
		if(ctoks.size() >= 5) {
			double mx;
			istringstream tmpss(ctoks[4]);
			tmpss >> mx;
			fv.setMax(mx);
		} else {
			fv.setMax(defaultMax);
		}
		return fv;
	}
}
