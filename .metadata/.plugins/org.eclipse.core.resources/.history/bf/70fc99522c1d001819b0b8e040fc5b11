package com.uwb.bt2j.aligner;
class Scoring<T> {

  enum CostModel {
    COST_MODEL_ROUNDED_QUAL(1),
    COST_MODEL_QUAL(2),
	  COST_MODEL_CONSTANT(3);
	  
	  private int x;
	  CostModel(int y){x = y;}
  };

  public static final CostModel DEFAULT_MATCH_BONUS_TYPE = CostModel.COST_MODEL_CONSTANT;
  public static final int DEFAULT_MATCH_BONUS = 0;
  public static final CostModel DEFAULT_MATCH_BONUS_TYPE_LOCAL = CostModel.COST_MODEL_CONSTANT;
  public static final int DEFAULT_MATCH_BONUS_LOCAL = 2;
  public static final CostModel DEFAULT_MM_PENALTY_TYPE = CostModel.COST_MODEL_QUAL;
  public static final CostModel DEFAULT_MM_PENALTY_TYPE_IGNORE_QUALS = CostModel.COST_MODEL_CONSTANT;
  public static final int DEFAULT_MM_PENALTY_MAX = 6;
  public static final int DEFAULT_MM_PENALTY_MIN = 2;
  public static final CostModel DEFAULT_N_PENALTY_TYPE = CostModel.COST_MODEL_CONSTANT;
  public static final int DEFAULT_N_PENALTY = 1;
  public static final float DEFAULT_MIN_CONST = -0.6f;
  public static final float DEFAULT_MIN_LINEAR = -0.6f;
  public static final float DEFAULT_MIN_CONST_LOCAL = 20.0f;
  public static final float DEFAULT_MIN_LINEAR_LOCAL = 8.0f;
  public static final float DEFAULT_N_CEIL_CONST = 0.0F;
  public static final float DEFAULT_n_ceil_linear = 0.15f;
  public static final Boolean DEFAULT_N_CAT_PAIR = false;
  public static final int DEFAULT_READ_GAP_CONST = 5;
  public static final int DEFAULT_READ_GAP_LINEAR = 3;
  public static final int DEFAULT_READ_GAP_CONST_BADHPOLY = 3;
  public static final int DEFAULT_READ_GAP_LINEAR_BADHPOLY = 1;
  public static final int DEFAULT_REF_GAP_CONST = 5;
  public static final int DEFAULT_REF_GAP_LINEAR = 3;
  public static final int DEFAULT_REF_GAP_CONST_BADHPOLY = 3;
  public static final int DEFAULT_REF_GAP_LINEAR_BADHPOLY = 1;
  
  public CostModel matchType;
  public int matchConst;
  public CostModel mmcostType;
  public int mmpMax;
  public int mmpMin;
  public SimpleFunc scoreMin;
  public SimpleFunc nCeil;
  public int npenType;
  public int npen;
  public Boolean ncatpair;
  public int rdGapConst;
  public int rfGapConst;
  public int rdGapLinear;
  public int rfGapLinear;
  public int gapbar;
  public Boolean monotone;
  public float matchBonuses[256];
  public int mmpens[256];
  public int npens[256];
  
  protected Boolean qualsMatter_;
  
  public Scoring(int   mat,          // reward for a match
			int   mmcType,      // how to penalize mismatches
		    int   mmpMax_,      // maximum mismatch penalty
		    int   mmpMin_,      // minimum mismatch penalty
		    SimpleFunc scoreMin_,   // minimum score for valid alignment; const coeff
			SimpleFunc nCeil_,      // max # ref Ns allowed in alignment; const coeff
		    int   nType,        // how to penalize Ns in the read
		    int   n,            // constant if N pelanty is a constant
			Boolean  ncat,         // whether to concatenate mates before N filtering
		    int   rdGpConst,    // constant coeff for cost of gap in the read
		    int   rfGpConst,    // constant coeff for cost of gap in the ref
		    int   rdGpLinear,   // coeff of linear term for cost of gap in read
		    int   rfGpLinear,   // coeff of linear term for cost of gap in ref
			int     gapbar_)    // # rows at top/bot can only be entered diagonally
  {
	  matchType    = CostModel.COST_MODEL_CONSTANT;
		matchConst   = mat;
		mmcostType   = mmcType;
		mmpMax       = mmpMax_;
		mmpMin       = mmpMin_;
		scoreMin     = scoreMin_;
		nCeil        = nCeil_;
		npenType     = nType;
		npen         = n;
		ncatpair     = ncat;
		rdGapConst   = rdGpConst;
		rfGapConst   = rfGpConst;
		rdGapLinear  = rdGpLinear;
		rfGapLinear  = rfGpLinear;
		qualsMatter_ = mmcostType != CostModel.COST_MODEL_CONSTANT;
		gapbar       = gapbar_;
		monotone     = matchType == CostModel.COST_MODEL_CONSTANT && matchConst == 0;
		initPens<Integer>(mmpens, mmcostType, mmpMin_, mmpMax_);
		initPens<Integer>(npens, npenType, npen, npen);
		initPens<float>(matchBonuses, matchType, matchConst, matchConst);
  }
  
  public void setMatchBonus(int bonus) {
		matchType  = CostModel.COST_MODEL_CONSTANT;
		matchConst = bonus;
		initPens<float>(matchBonuses, matchType, matchConst, matchConst);
  }
  
  public void setMmPen(CostModel mmType_, int mmpMax_, int mmpMin_) {
		mmcostType = mmType_;
		mmpMax     = mmpMax_;
		mmpMin     = mmpMin_;
		initPens<int>(mmpens, mmcostType, mmpMin, mmpMax);
  }
  
  public void setNPen(int nType, int n) {
	  npenType     = nType;
		npen         = n;
		initPens<int>(npens, npenType, npen, npen);
  }
  
  public static float linearFunc(long x, float cnst, float lin) {
	  return (float)((double)cnst + ((double)lin * x));
  }
  
  public int mm(int rdc, int refm, int q) {
	  return (rdc > 3 || refm > 15) ? npens[q] : mmpens[q];
  }
  
  public int mm(int rdc, int q) {
	  return (rdc > 3) ? npens[q] : mmpens[q];
  }
  
  public int mm(int q) {
	  return q < 255 ? mmpens[q] : mmpens[255];
  }
  
  public int score(int rdc, int refm, int q) {
	  if(rdc > 3 || refm > 15) {
			return -npens[q];
		}
		if((refm & (1 << rdc)) != 0) {
			return (int)matchBonuses[q];
		} else {
			return -mmpens[q];
		}
  }
  
  public int score(int rdc, int refm, int q, int& ns) {
	  if(rdc > 3 || refm > 15) {
			ns++;
			return -npens[q];
		}
		if((refm & (1 << rdc)) != 0) {
			return (int)matchBonuses[q];
		} else {
			return -mmpens[q];
		}
  }
  
  public final long match(int q) {
		return (long)((q < 255 ? matchBonuses[q] : matchBonuses[255]) + 0.5f);
  }
  
  public final long match() {
    return match(30);
  }
  
  public final long perfectScore(long rdlen) {
		if(monotone) {
			return 0;
		} else {
			return rdlen * match(30);
		}
  }
  
  public final Boolean qualitiesMatter() {
	  return qualsMatter_;
  }
  
  public final int n(int q) {
	  return q < 255 ? npens[q] : npens[255];
  }
  
  public final int ins() {
    
  }
  
  public final int del() {
    
  }
  
  public final Boolean scoreFilter() {
    
  }
  
  public final int maxReadGaps() {
    
  }
  
  public final int maxRefGaps() {
    
  }
  
  public final Boolean nFilter() {
    
  }
  
  public void nFilterPair() {
    
  }
  
  public final int readGapOpen() {
    
  }
  
  public final int refGapOpen() {
    
  }
  
  public final int readGapExtend() {
    
  }
  
  public final int refGapExtend() {
  
  }
  
  public void initPens(T pens, CostModel type, int consMin, int consMax) {
		if(type == CostModel.COST_MODEL_ROUNDED_QUAL) {
			for(int i = 0; i < 256; i++) {
				pens[i] = (T)qualRounds[i];
			}
		} else if(type == CostModel.COST_MODEL_QUAL) {
			for(int i = 0; i < 256; i++) {
				int ii = Math.min(i, 40); // TODO: Bit hacky, this
				float frac = (float)ii / 40.0f;
				pens[i] = consMin + (T)(frac * (consMax-consMin));
			}
		} else if(type == CostModel.COST_MODEL_CONSTANT) {
			for(int i = 0; i < 256; i++) {
				pens[i] = (T)consMax;
			}
		}
  }
  
  public static Scoring base1() {
  
  }
}
