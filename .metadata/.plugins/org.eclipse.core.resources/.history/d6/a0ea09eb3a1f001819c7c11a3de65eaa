package com.uwb.bt2j.aligner.dp;
import com.uwb.bt2j.aligner.Edit;
import com.uwb.bt2j.aligner.RandomSource;
import com.uwb.bt2j.util.types.EFactory;
import com.uwb.bt2j.util.types.ELList;
import com.uwb.bt2j.util.types.ELSet;
import com.uwb.bt2j.util.types.EList;

import javafx.util.Pair;

class BtBranchTracer {
  protected BtBranchProblem prob_;
  protected EFactory<BtBranch> bs_;
  protected ELList<Pair<Double,Double>> seenPaths_;
  protected ELSet<Double> sawcell_;
  protected EList<Pair<Double,Double>> unsorted_;
  protected EList<Double> sorted1_;
  protected EList<Double> sorted2_;
  protected EList<Double> solutions_;
  protected Boolean sortedSel_;
  protected double cur_;
  protected double nmm_;
  protected double nnmm_;
  protected double nrdop_;
  protected double nrfop_;
  protected double nrdex_;
  protected double nrfex_;
  protected double nmmPrune_;
  protected double nnmmPrune_;
  protected double nrdopPrune_;
  protected double nrfopPrune_;
  protected double nrdexPrune_;
  protected double nrfexPrune_;
  protected double row_;
  protected double col_;
  protected Boolean doTri_;
  protected EList<CpQuad> sq_;
  protected EList<double> ndep_;
  protected ELList<CpQuad> tri_;

  public BtBranchTracer() {
    seenPaths_ = 6;
    sawCell_ = 6;
  }
  
  public void add(long id) {
	  unsorted_.push_back(new Pair(bs_[id].score_st_, id));
  }
  
  public void addSolution(long id) {
	  solutions_.push_back(id);
  }
  
  public void examineBranch(
		  long row,
			long col,
			Edit e,
			long pen,
			long sc,
			long parentId){
  
  }
  
  public void addOffshoots(long bid) {
    
  }
  
  public double best(RandomSource rnd) {
	  flushUnsorted();
		// Perhaps shuffle everyone who's tied for first?
		long id = sortedSel_ ? sorted1_[cur_] : sorted2_[cur_];
		cur_++;
		return id;
  }
  
  public boolean empty() {
    return size() == 0;
  }
  
  public double size() {
	  return unsorted_.size() +
		       (sortedSel_ ? sorted1_.size() : sorted2_.size()) - cur_;
  }
  
  public boolean emptySolution() {
	  return sizeSolution() == 0;
  }
  
  public long sizeSolution() {
	  return solutions_.size();
  }
  
  public void flushUnsorted() {
    
  }
  
  public void initRef(
		  String         rd,     // in: read sequence
			String         qu,     // in: quality sequence
			long              rdlen,  // in: read sequence length
			String         rf,     // in: reference sequence
			long              rflen,  // in: in-rectangle reference sequence length
			long             trflen, // in: total reference sequence length
			long              refid,  // in: reference id
			long             refoff, // in: reference offset
			boolean                fw,     // in: orientation
			DPRect       rect,   // in: DP rectangle
			Checkpointer cper,   // in: checkpointer
			Scoring      sc,     // in: scoring scheme
			long              nceil)  // in: N ceiling
  {
	  prob_.initRef(rd, qu, rdlen, rf, rflen, trflen, refid, refoff, fw, rect, cper, sc, nceil);
		long ndiag = rflen + rdlen - 1;
		seenPaths_.resize(ndiag);
		for(int i = 0; i < ndiag; i++) {
			seenPaths_[i].clear();
		}
		// clear each of the per-column sets
		if(sawcell_.size() < rflen) {
			int isz = sawcell_.size();
			sawcell_.resize(rflen);
			for(int i = isz; i < rflen; i++) {
				sawcell_[i].setCat(6);
			}
		}
		for(int i = 0; i < rflen; i++) {
			sawcell_[i].setCat(6);
			sawcell_[i].clear(); // clear the set
		}
  }
  
  public void initBt(
		  TAlScore       escore, // in: alignment score
			size_t         row,    // in: start in this row
			size_t         col,    // in: start in this column
			bool           fill,   // in: use mini-filling?
			bool           usecp,  // in: use checkpointing?
			bool           doTri,  // in: triangle-shaped mini-fills?
			RandomSource&  rnd)    // in: random gen, to choose among equal paths
  {
	  prob_.initBt(row, col, fill, usecp, escore);
		Edit e; e.reset();
		unsorted_.clear();
		solutions_.clear();
		sorted1_.clear();
		sorted2_.clear();
		cur_ = 0;
		nmm_ = 0;         // number of mismatches attempted
		nnmm_ = 0;        // number of mismatches involving N attempted
		nrdop_ = 0;       // number of read gap opens attempted
		nrfop_ = 0;       // number of ref gap opens attempted
		nrdex_ = 0;       // number of read gap extensions attempted
		nrfex_ = 0;       // number of ref gap extensions attempted
		nmmPrune_ = 0;    // number of mismatches attempted
		nnmmPrune_ = 0;   // number of mismatches involving N attempted
		nrdopPrune_ = 0;  // number of read gap opens attempted
		nrfopPrune_ = 0;  // number of ref gap opens attempted
		nrdexPrune_ = 0;  // number of read gap extensions attempted
		nrfexPrune_ = 0;  // number of ref gap extensions attempted
		row_ = row;
		col_ = col;
		doTri_ = doTri;
		bs_.clear();
		if(!prob_.fill_) {
			size_t id = bs_.alloc();
			bs_[id].init(
				prob_,
				0,     // parent id
				0,     // penalty
				0,     // starting score
				row,   // row
				col,   // column
				e,
				0,
			    true,  // this is the root
				true); // this should be extend with exact matches
			if(bs_[id].isSolution(prob_)) {
				addSolution(id);
			} else {
				add(id);
			}
		} else {
			int64_t row = row_, col = col_;
			TAlScore targsc = prob_.targ_;
			int hef = 0;
			bool done = false, abort = false;
			size_t depth = 0;
			while(!done && !abort) {
				// Accumulate edits as we go.  We can do this by adding
				// BtBranches to the bs_ structure.  Each step of the backtrace
				// either involves an edit (thereby starting a new branch) or
				// extends the previous branch by one more position.
				//
				// Note: if the BtBranches are in line, then trySolution can be
				// used to populate the SwResult and check for various
				// situations where we might reject the alignment (i.e. due to
				// a cell having been visited previously).
				if(doTri_) {
					triangleFill(
						row,          // row of cell to backtrace from
						col,          // column of cell to backtrace from
						hef,          // cell to bt from: H (0), E (1), or F (2)
						targsc,       // score of cell to backtrace from
						prob_.targ_,  // score of alignment we're looking for
						rnd,          // pseudo-random generator
						row,          // out: row we ended up in after bt
						col,          // out: column we ended up in after bt
						hef,          // out: H/E/F after backtrace
						targsc,       // out: score up to cell we ended up in
						done,         // out: finished tracing out an alignment?
						abort);       // out: aborted b/c cell was seen before?
				} else {
					squareFill(
						row,          // row of cell to backtrace from
						col,          // column of cell to backtrace from
						hef,          // cell to bt from: H (0), E (1), or F (2)
						targsc,       // score of cell to backtrace from
						prob_.targ_,  // score of alignment we're looking for
						rnd,          // pseudo-random generator
						row,          // out: row we ended up in after bt
						col,          // out: column we ended up in after bt
						hef,          // out: H/E/F after backtrace
						targsc,       // out: score up to cell we ended up in
						done,         // out: finished tracing out an alignment?
						abort);       // out: aborted b/c cell was seen before?
				}
				if(depth >= ndep_.size()) {
					ndep_.resize(depth+1);
					ndep_[depth] = 1;
				} else {
					ndep_[depth]++;
				}
				depth++;
				assert((row >= 0 && col >= 0) || done);
			}
		}
  }
  
  public boolean nextAlignment(
		  size_t maxiter,
			SwResult& res,
			size_t& off,
			size_t& nrej,
			size_t& niter,
			RandomSource& rnd)
  {
    
  }
  
  public boolean inited() {
	  return prob_.inited();
  }
  
  public Boolean doTri() {
  
  }
  
  public void triangleFill(
		  int64_t rw,          // row of cell to backtrace from
			int64_t cl,          // column of cell to backtrace from
			int hef,             // cell to backtrace from is H (0), E (1), or F (2)
			TAlScore targ,       // score of cell to backtrace from
			TAlScore targ_final, // score of alignment we're looking for
			RandomSource& rnd,   // pseudo-random generator
			int64_t& row_new,    // out: row we ended up in after backtrace
			int64_t& col_new,    // out: column we ended up in after backtrace
			int& hef_new,        // out: H/E/F after backtrace
			TAlScore& targ_new,  // out: score up to cell we ended up in
			bool& done,          // out: finished tracing out an alignment?
			bool& abort)        // out: aborted b/c cell was seen before?
  {
  
  }
  
  public void squareFill(
		  int64_t rw,          // row of cell to backtrace from
			int64_t cl,          // column of cell to backtrace from
			int hef,             // cell to backtrace from is H (0), E (1), or F (2)
			TAlScore targ,       // score of cell to backtrace from
			TAlScore targ_final, // score of alignment we're looking for
			RandomSource& rnd,   // pseudo-random generator
			int64_t& row_new,    // out: row we ended up in after backtrace
			int64_t& col_new,    // out: column we ended up in after backtrace
			int& hef_new,        // out: H/E/F after backtrace
			TAlScore& targ_new,  // out: score up to cell we ended up in
			bool& done,          // out: finished tracing out an alignment?
			bool& abort)        // out: aborted b/c cell was seen before?
  {
  
  }
  
  protected Boolean nextAlignmentBacktrace(
		  size_t maxiter,
			SwResult& res,
			size_t& off,
			size_t& nrej,
			size_t& niter,
			RandomSource& rnd)
  {
    
  }
  
  protected Boolean nextAlignmentFill(
		  size_t maxiter,
			SwResult& res,
			size_t& off,
			size_t& nrej,
			size_t& niter,
			RandomSource& rnd)
  {
    
  }
  
  protected Boolean trySolutions(
		  bool lookForOlap,
			SwResult& res,
			size_t& off,
			size_t& nrej,
			RandomSource& rnd,
			bool& success)
  {
  
  }
  
  protected int trySolution(
		  size_t id,
			bool lookForOlap,
			SwResult& res,
			size_t& off,
			size_t& nrej,
			RandomSource& rnd)
  {
  
  }
}
