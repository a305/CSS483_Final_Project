package com.uwb.bt2j.aligner;

public class SAMConfig<T, TStr> {
	
	protected Boolean truncQname_;   // truncate QNAME to 255 chars?
	protected Boolean omitsec_;      // omit secondary 
	protected Boolean noUnal_;       // omit unaligned reads
	
	protected String pg_id_; // @PG ID: Program record identifier
	protected String pg_pn_; // @PG PN: Program name
	protected String pg_vn_; // @PG VN: Program version
	protected String pg_cl_; // @PG CL: Program command-line
	protected String rgs_;   // Read-group string to add to all records
	EList<String> refnames_; // reference sequence names
	EList<double> reflens_;  // reference sequence lengths
	
	// Which alignment flags to print?

	// Following are printed by BWA-SW
	protected Boolean print_as_; // AS:i: Alignment score generated by aligner
	protected Boolean print_xs_; // XS:i: Suboptimal alignment score
	protected Boolean print_xss_;// Xs:i: Best invalid alignment score found
	protected Boolean print_yn_; // YN:i:, Yn:i: minimum valid score and perfect score
	protected Boolean print_xn_; // XN:i: Number of ambiguous bases in the referenece

	// Following are printed by BWA
	protected Boolean print_x0_; // X0:i: Number of best hits
	protected Boolean print_x1_; // X1:i: Number of sub-optimal best hits
	protected Boolean print_xm_; // XM:i: Number of mismatches in the alignment
	protected Boolean print_xo_; // XO:i: Number of gap opens
	protected Boolean print_xg_; // XG:i: Number of gap extensions (incl. opens)
	protected Boolean print_nm_; // NM:i: Edit dist. to the ref, Ns count, clipping doesn't
	protected Boolean print_md_; // MD:Z: String for mms. [0-9]+(([A-Z]|\^[A-Z]+)[0-9]+)*2

	// Following are Bowtie2-specific
	protected Boolean print_yf_; // YF:i: Read was filtered out?
	protected Boolean print_yi_; // YI:Z: Summary of inputs to MAPQ calculation
	protected Boolean print_ym_; // YM:i: Read was repetitive when aligned unpaired?
	protected Boolean print_yp_; // YP:i: Read was repetitive when aligned paired?
	protected Boolean print_yt_; // YT:Z: String representing alignment type
	protected Boolean print_ys_; // YS:i: Score of other mate
	protected Boolean print_zs_; // ZS:i: Pseudo-random seed
	
	protected Boolean print_xr_; // XR:Z: Original read string
	protected Boolean print_xt_; // XT:i: Time taken to align
	protected Boolean print_xd_; // XD:i: DP problems
	protected Boolean print_xu_; // XU:i: ungapped alignment
	protected Boolean print_ye_; // YE:i: streak of failed DPs at end
	protected Boolean print_yl_; // YL:i: longest streak of failed DPs
	protected Boolean print_yu_; // YU:i: index of last succeeded DP
	protected Boolean print_xp_; // XP:BI: seed hit information
	protected Boolean print_yr_; // YR:i: # redundant seed hits
	protected Boolean print_zb_; // ZB:i: # Ftab lookups
	protected Boolean print_zr_; // ZR:i: # redundant path checks
	protected Boolean print_zf_; // ZF:i: # FM Index ops
	protected Boolean print_zm_; // ZM:i: FM ops string for best-first search
	protected Boolean print_zi_; // ZI:i: # extend loop iters
	protected Boolean print_zp_; // ZP:i: Score of best/second-best paired-end alignment
	protected Boolean print_zu_; // ZU:i: Score of best/second-best unpaired alignment
	protected Boolean print_zt_; // ZT:Z: Extra features for MAPQ estimation
	
	public enum SamFlags {
		// Comments use language from v1.4-r962 spec
		SAM_FLAG_PAIRED(1),   // templ. having mult. frag.s in sequencing
		SAM_FLAG_MAPPED_PAIRED(2),   // each frag properly aligned
		SAM_FLAG_UNMAPPED(4),   // fragment unmapped
		SAM_FLAG_MATE_UNMAPPED(8),   // next fragment in template unmapped
		SAM_FLAG_QUERY_STRAND(16),  // SEQ is reverse comp'ed from original
		SAM_FLAG_MATE_STRAND(32),  // next fragment SEQ reverse comp'ed
		SAM_FLAG_FIRST_IN_PAIR(64),  // first fragment in template
		SAM_FLAG_SECOND_IN_PAIR(128), // last fragment in template
		SAM_FLAG_NOT_PRIMARY(256), // secondary alignment
		SAM_FLAG_FAILS_CHECKS(512), // not passing quality controls
		SAM_FLAG_DUPLICATE(1024); // PCR or optical duplicate
		private int x;
		SamFlags(int y){x = y;}
	}
	public SamConfig(
			EList<String> refnames,  // reference sequence names
			EList<double> reflens,   // reference sequence lengths
			Boolean truncQname,          // truncate read name to 255?
			Boolean omitsec,             // omit secondary SEQ/QUAL
			Boolean noUnal,              // omit unaligned reads
			String pg_id, // id
			String pg_pn, // name
			String pg_vn, // version
			String pg_cl, // command-line
			String rgs,   // read groups string
			Boolean print_as,
			Boolean print_xs,
			Boolean print_xss,
			Boolean print_yn,
			Boolean print_xn,
			Boolean print_x0,
			Boolean print_x1,
			Boolean print_xm,
			Boolean print_xo,
			Boolean print_xg,
			Boolean print_nm,
			Boolean print_md,
			Boolean print_yf,
			Boolean print_yi,
			Boolean print_ym,
			Boolean print_yp,
			Boolean print_yt,
			Boolean print_ys,
			Boolean print_zs,
			Boolean print_xr,
			Boolean print_xt,
			Boolean print_xd,
			Boolean print_xu,
			Boolean print_ye, // streak of failed DPs at end
			Boolean print_yl, // longest streak of failed DPs
			Boolean print_yu, // index of last succeeded DP
			Boolean print_xp, // print seed hit information
			Boolean print_yr, // # redundant seed hits
			Boolean print_zb, // # Ftab lookups
			Boolean print_zr, // # redundant path checks
			Boolean print_zf, // # FM Index ops
			Boolean print_zm, // FM Index op string for best-first search
			Boolean print_zi, // # seed extend loop iters
			Boolean print_zp,
			Boolean print_zu,
			Boolean print_zt) {
		truncQname_ = truncQname;
		omitsec_ = omitsec;
		noUnal_ = noUnal;
		pg_id_ = pg_id;
		pg_pn_=pg_pn;
		pg_vn_=pg_vn;
		pg_cl_=pg_cl;
		rgs_=rgs;
		refnames_=refnames;
		reflens_=reflens;
		print_as_=print_as; // alignment score of best alignment
		print_xs_=print_xs; // alignment score of second-best alignment
		print_xss_=print_xss;
		print_yn_=print_yn; // minimum valid score and perfect score
		print_xn_=print_xn;
		print_x0_=print_x0;
		print_x1_=print_x1;
		print_xm_=print_xm;
		print_xo_=print_xo;
		print_xg_=print_xg;
		print_nm_=print_nm;
		print_md_=print_md;
		print_yf_=print_yf;
		print_yi_=print_yi;
		print_ym_=print_ym;
		print_yp_=print_yp;
		print_yt_=print_yt;
		print_ys_=print_ys;
		print_zs_=print_zs;
		print_xr_=print_xr;
		print_xt_=print_xt; // time elapsed in microseconds
		print_xd_=print_xd; // DP extend attempts
		print_xu_=print_xu; // ungapped extend attempts
		print_ye_=print_ye; // streak of failed DPs at end
		print_yl_=print_yl; // longest streak of failed DPs
		print_yu_=print_yu; // index of last succeeded DP
		print_xp_=print_xp; // print seed hit information
		print_yr_=print_yr; // index of last succeeded DP
		print_zb_=print_zb; // # Ftab lookups
		print_zr_=print_zr; // # redundant path checks
		print_zf_=print_zf; // # FM Index ops
		print_zm_=print_zm; // FM Index op string for best-first search
		print_zi_=print_zi; // # seed extend loop iters
		print_zp_=print_zp; // # seed extend loop iters
		print_zu_=print_zu; // # seed extend loop iters
		print_zt_=print_zt;  // extra features for MAPQ estimation
	}
	
	public void printRefNameFromIndex(BTString o, double i) {
		printRefName(o, refnames_[i]);
	}
	
	public void printRefName(BTString o, String name) {
		double namelen = name.length();
		for(double i = 0; i < namelen; i++) {
			if(isspace(name[i])) {
				return;
			}
			o.append(name[i]);
		}
	}
	
	public void printOptFieldEscapedZ(BTString o, T s) {
		double len = s.length();
		for(double i = 0; i < len; i++) {
			if(s[i] < 33 || s[i] > 126 || s[i] == ':' || s[i] == '%') {
				// percent-encode it
				o.append('%');
				int ms = s[i] >> 4;
				int ls = s[i] & 15;
				o.append("0123456789ABCDEF"[ms]);
				o.append("0123456789ABCDEF"[ls]);
			} else {
				o.append(s[i]);
			}
		}
	}
	
	public void printOptFieldNewlineEscapedZ(BTString o, T s) {
		double len = s.length();
		for(double i = 0; i < len; i++) {
			if(s[i] == 10 || s[i] == 13 || s[i] == '%') {
				// percent-encode it
				o.append('%');
				int ms = s[i] >> 4;
				int ls = s[i] & 15;
				o.append("0123456789ABCDEF"[ms]);
				o.append("0123456789ABCDEF"[ls]);
			} else {
				o.append(s[i]);
			}
		}
	}
	
	public void printReadName(
			BTString o,
			TStr name,
			Boolean omitSlashMate)
		{
			double namelen = name.length();
			if(omitSlashMate &&
			   namelen >= 2 &&
			   name[namelen-2] == '/' &&
			   (name[namelen-1] == '1' || name[namelen-1] == '2' || name[namelen-1] == '3'))
			{
				namelen -= 2;
			}
			if(truncQname_ && namelen > 255) {
				namelen = 255;
			}
			for(double i = 0; i < namelen; i++) {
				if(truncQname_ && isspace(name[i])) {
					return;
				}
				o.append(name[i]);
			}
		}
	
	public void printRefNameFromIndex(
			BTString o,
			double i) {
		printRefName(o, refnames_[i]);
	}
	
	public void printHeader(BTString o,
			String rgid,
			String rgs,
			Boolean printHd,
			Boolean printSq,
			Boolean printPg) {
		if(printHd) printHdLine(o, "1.0");
		if(printSq) printSqLines(o);
		if(!rgid.empty()) {
			o.append("@RG");
			o.append(rgid);
			o.append(rgs);
			o.append('\n');
		}
		if(printPg) printPgLine(o);
	}
	
	public void printHdLine(BTString o, String samver) {
		o.append("@HD\tVN:");
		o.append(samver);
		o.append("\tSO:unsorted\n");
	}
	
	public void printSqLines(BTString o) {
		String buf;
		for(double i = 0; i < refnames_.size(); i++) {
			o.append("@SQ\tSN:");
			printRefName(o, refnames_[i]);
			o.append("\tLN:");
			buf = Integer.parseInt(reflens_[i]);
			o.append(buf);
			o.append('\n');
		}
	}
	
	public void printPgLine(BTString o) {
		o.append("@PG\tID:");
		o.append(pg_id_);
		o.append("\tPN:");
		o.append(pg_pn_);
		o.append("\tVN:");
		o.append(pg_vn_);
		o.append("\tCL:\"");
		o.append(pg_cl_);
		o.append('"');
		o.append('\n');
	}
	
	public void printAlignedOptFlags(
			BTString o,               // output buffer
			Boolean first,                // first opt flag printed is first overall?
			Read rd,            // the read
			Read rdo,           // the opposite read
			AlignerResult res,               // individual alignment result
			StackedAlignment staln,         // stacked alignment
			AlnFlags flags,     // alignment flags
			AlnSetSumm summ,    // summary of alignments for this read
			SeedAlSumm ssm,     // seed alignment summary
			PerReadMetrics prm, // per-read metics
			Scoring sc,         // scoring scheme
			String mapqInp) {       // inputs to MAPQ calculation{
		String buf;
		if(print_as_) {
			// AS:i: Alignment score generated by aligner
			itoa10<long>(res.score().score(), buf);
			WRITE_SEP();
			o.append("AS:i:");
			o.append(buf);
		}
		if(print_xs_) {
			// XS:i: Suboptimal alignment score
			AlignmentScore sco;
			if(flags.partOfPair()) {
				sco = summ.bestUnchosenPScore(rd.mate < 2);
			} else {
				sco = summ.bestUnchosenUScore();
			}
			if(sco.valid()) {
				itoa10<long>(sco.score(), buf);
				WRITE_SEP();
				o.append("XS:i:");
				o.append(buf);
			}
		}
		if(print_xn_) {
			// XN:i: Number of ambiguous bases in the referenece
			itoa10<double>(res.refNs(), buf);
			WRITE_SEP();
			o.append("XN:i:");
			o.append(buf);
		}
		if(print_x0_) {
			// X0:i: Number of best hits
		}
		if(print_x1_) {
			// X1:i: Number of sub-optimal best hits
		}
		double num_mm = 0;
		double num_go = 0;
		double num_gx = 0;
		for(double i = 0; i < res.ned().size(); i++) {
			if(res.ned()[i].isMismatch()) {
				num_mm++;
			} else if(res.ned()[i].isReadGap()) {
				num_go++;
				num_gx++;
				while(i < res.ned().size()-1 &&
					  res.ned()[i+1].pos == res.ned()[i].pos &&
					  res.ned()[i+1].isReadGap())
				{
					i++;
					num_gx++;
				}
			} else if(res.ned()[i].isRefGap()) {
				num_go++;
				num_gx++;
				while(i < res.ned().size()-1 &&
					  res.ned()[i+1].pos == res.ned()[i].pos+1 &&
					  res.ned()[i+1].isRefGap())
				{
					i++;
					num_gx++;
				}
			}
		}
		if(print_xm_) {
			// XM:i: Number of mismatches in the alignment
			itoa10<double>(num_mm, buf);
			WRITE_SEP();
			o.append("XM:i:");
			o.append(buf);
		}
		if(print_xo_) {
			// XO:i: Number of gap opens
			itoa10<double>(num_go, buf);
			WRITE_SEP();
			o.append("XO:i:");
			o.append(buf);
		}
		if(print_xg_) {
			// XG:i: Number of gap extensions (incl. opens)
			itoa10<double>(num_gx, buf);
			WRITE_SEP();
			o.append("XG:i:");
			o.append(buf);
		}
		if(print_nm_) {
			// NM:i: Edit dist. to the ref, Ns count, clipping doesn't
			itoa10<double>(res.ned().size(), buf);
			WRITE_SEP();
			o.append("NM:i:");
			o.append(buf);
		}
		if(print_md_) {
			// MD:Z: String for mms. [0-9]+(([A-Z]|\^[A-Z]+)[0-9]+)*2
			WRITE_SEP();
			o.append("MD:Z:");
			staln.buildMdz();
			staln.writeMdz(
				&o,        // output buffer
				NULL);     // no char buffer
		}
		if(print_ys_ && summ.paired()) {
			// YS:i: Alignment score of opposite mate
			itoa10<long>(res.oscore().score(), buf);
			WRITE_SEP();
			o.append("YS:i:");
			o.append(buf);
		}
		if(print_yn_) {
			// YN:i: Minimum valid score for this mate
			long mn = sc.scoreMin.f<long>(rd.length());
			itoa10<long>(mn, buf);
			WRITE_SEP();
			o.append("YN:i:");
			o.append(buf);
			// Yn:i: Perfect score for this mate
			long pe = sc.perfectScore(rd.length());
			itoa10<long>(pe, buf);
			WRITE_SEP();
			o.append("Yn:i:");
			o.append(buf);
			if(summ.paired()) {
				// ZN:i: Minimum valid score for opposite mate
				long mn = sc.scoreMin.f<long>(rdo->length());
				itoa10<long>(mn, buf);
				WRITE_SEP();
				o.append("ZN:i:");
				o.append(buf);
				// Zn:i: Perfect score for opposite mate
				long pe = sc.perfectScore(rdo->length());
				itoa10<long>(pe, buf);
				WRITE_SEP();
				o.append("Zn:i:");
				o.append(buf);
			}
		}
		if(print_xss_) {
			// Xs:i: Best invalid alignment score of this mate
			Boolean one = true;
			if(flags.partOfPair() && !flags.readMate1()) {
				one = false;
			}
			long bst = one ? prm.bestLtMinscMate1 : prm.bestLtMinscMate2;
			if(bst > Long.MIN_VALUE) {
				itoa10<long>(bst, buf);
				WRITE_SEP();
				o.append("Xs:i:");
				o.append(buf);
			}
			if(flags.partOfPair()) {
				// Ys:i: Best invalid alignment score of opposite mate
				bst = one ? prm.bestLtMinscMate2 : prm.bestLtMinscMate1;
				if(bst > Long.MIN_VALUE) {
					itoa10<long>(bst, buf);
					WRITE_SEP();
					o.append("Ys:i:");
					o.append(buf);
				}
			}
		}
		if(print_zs_) {
			// ZS:i: Pseudo-random seed for read
			itoa10<double>(rd.seed, buf);
			WRITE_SEP();
			o.append("ZS:i:");
			o.append(buf);
		}
		if(print_yt_) {
			// YT:Z: String representing alignment type
			WRITE_SEP();
			flags.printYT(o);
		}
		if(print_yp_ && flags.partOfPair() && flags.canMax()) {
			// YP:i: Read was repetitive when aligned paired?
			WRITE_SEP();
			flags.printYP(o);
		}
		if(print_ym_ && flags.canMax() && (flags.isMixedMode() || !flags.partOfPair())) {
			// YM:i: Read was repetitive when aligned unpaired?
			WRITE_SEP();
			flags.printYM(o);
		}
		if(print_yf_ && flags.filtered()) {
			// YF:i: Read was filtered?
			first = flags.printYF(o, first) && first;
		}
		if(print_yi_) {
			// Print MAPQ calibration info
			if(mapqInp[0] != '\0') {
				// YI:i: Suboptimal alignment score
				WRITE_SEP();
				o.append("YI:Z:");
				o.append(mapqInp);
			}
		}
		if(flags.partOfPair() && print_zp_) {
			// ZP:i: Score of best concordant paired-end alignment
			if(summ.bestCScore().valid()) {
				WRITE_SEP();
				o.append("ZP:i:");
				itoa10<long>(summ.bestCScore().score(), buf);
				o.append(buf);
			}
			// Zp:i: Score of second-best concordant paired-end alignment
			if(summ.bestUnchosenCScore().valid()) {
				WRITE_SEP();
				o.append("Zp:i:");
				itoa10<long>(summ.bestUnchosenCScore().score(), buf);
				o.append(buf);
			}
		}
		if(print_zu_) {
			// ZU:i: Score of best unpaired alignment
			AlignmentScore best    = summ.bestScore(rd.mate <= 1);
			AlignmentScore secbest = summ.bestUnchosenPScore(rd.mate <= 1);
			WRITE_SEP();
			o.append("ZU:i:");
			if(best.valid()) {
				itoa10<long>(best.score(), buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
			// Zu:i: Score of second-best unpaired alignment
			WRITE_SEP();
			o.append("Zu:i:");
			if(secbest.valid()) {
				itoa10<long>(secbest.score(), buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
		}
		if(!rgs_.empty()) {
			WRITE_SEP();
			o.append(rgs_.c_str());
		}
		if(print_xt_) {
			// XT:i: Timing
			WRITE_SEP();
			gettimeofday(&tv_end, &tz_end);
			o.append("XT:i:");
			o.append(buf);
		}
		if(print_xd_) {
			// XD:i: Extend DPs
			WRITE_SEP();
			itoa10<long>(prm.nExDps, buf);
			o.append("XD:i:");
			o.append(buf);
			// Xd:i: Mate DPs
			WRITE_SEP();
			itoa10<long>(prm.nMateDps, buf);
			o.append("Xd:i:");
			o.append(buf);
		}
		if(print_xu_) {
			// XU:i: Extend ungapped tries
			WRITE_SEP();
			itoa10<long>(prm.nExUgs, buf);
			o.append("XU:i:");
			o.append(buf);
			// Xu:i: Mate ungapped tries
			WRITE_SEP();
			itoa10<long>(prm.nMateUgs, buf);
			o.append("Xu:i:");
			o.append(buf);
		}
		if(print_ye_) {
			// YE:i: Streak of failed DPs at end
			WRITE_SEP();
			itoa10<long>(prm.nDpFail, buf);
			o.append("YE:i:");
			o.append(buf);
			// Ye:i: Streak of failed ungaps at end
			WRITE_SEP();
			itoa10<long>(prm.nUgFail, buf);
			o.append("Ye:i:");
			o.append(buf);
		}
		if(print_yl_) {
			// YL:i: Longest streak of failed DPs
			WRITE_SEP();
			itoa10<long>(prm.nDpFailStreak, buf);
			o.append("YL:i:");
			o.append(buf);
			// Yl:i: Longest streak of failed ungaps
			WRITE_SEP();
			itoa10<long>(prm.nUgFailStreak, buf);
			o.append("Yl:i:");
			o.append(buf);
		}
		if(print_yu_) {
			// YU:i: Index of last succesful DP
			WRITE_SEP();
			itoa10<long>(prm.nDpLastSucc, buf);
			o.append("YU:i:");
			o.append(buf);
			// Yu:i: Index of last succesful DP
			WRITE_SEP();
			itoa10<long>(prm.nUgLastSucc, buf);
			o.append("Yu:i:");
			o.append(buf);
		}
		if(print_xp_) {
			// XP:Z: String describing seed hits
			WRITE_SEP();
			o.append("XP:B:I,");
			itoa10<long>(prm.nSeedElts, buf);
			o.append(buf);
			o.append(',');
			itoa10<long>(prm.nSeedEltsFw, buf);
			o.append(buf);
			o.append(',');
			itoa10<long>(prm.nSeedEltsRc, buf);
			o.append(buf);
			o.append(',');
			itoa10<long>(prm.seedMean, buf);
			o.append(buf);
			o.append(',');
			itoa10<long>(prm.seedMedian, buf);
			o.append(buf);
		}
		if(print_yr_) {
			// YR:i: Redundant seed hits
			WRITE_SEP();
			itoa10<long>(prm.nRedundants, buf);
			o.append("YR:i:");
			o.append(buf);
		}
		if(print_zb_) {
			// ZB:i: Ftab ops for seed alignment
			WRITE_SEP();
			itoa10<long>(prm.nFtabs, buf);
			o.append("ZB:i:");
			o.append(buf);
		}
		if(print_zr_) {
			// ZR:Z: Redundant path skips in seed alignment
			WRITE_SEP();
			o.append("ZR:Z:");
			itoa10<long>(prm.nRedSkip, buf); o.append(buf);
			o.append(',');
			itoa10<long>(prm.nRedFail, buf); o.append(buf);
			o.append(',');
			itoa10<long>(prm.nRedIns, buf); o.append(buf);
		}
		if(print_zf_) {
			// ZF:i: FM Index ops for seed alignment
			WRITE_SEP();
			itoa10<long>(prm.nSdFmops, buf);
			o.append("ZF:i:");
			o.append(buf);
			// Zf:i: FM Index ops for offset resolution
			WRITE_SEP();
			itoa10<long>(prm.nExFmops, buf);
			o.append("Zf:i:");
			o.append(buf);
		}
		if(print_zm_) {
			// ZM:Z: Print FM index op string for best-first search
			WRITE_SEP();
			o.append("ZM:Z:");
			prm.fmString.print(o, buf);
		}
		if(print_zi_) {
			// ZI:i: Seed extend loop iterations
			WRITE_SEP();
			itoa10<long>(prm.nExIters, buf);
			o.append("ZI:i:");
			o.append(buf);
		}
		if(print_xr_) {
			// Original read string
			o.append("\n");
			printOptFieldNewlineEscapedZ(o, rd.readOrigBuf);
		}
		if(print_zt_) {
			// ZT:Z: Extra features for MAPQ estimation
			WRITE_SEP();
			Boolean paired = flags.partOfPair();
			long MN = Long.MIN_VALUE;
			long secondBest[2] = {MN, MN};
			long thirdBest[2] = {MN, MN};
			int ED_MAX = Integer.MAX_VALUE;
			AlignmentScore best[2] = {res.score(), res.oscore()};
			long diffEd[2] = {ED_MAX, ED_MAX};
			for (int self = 0; self < (paired ? 2 : 1); self++) {
				// Second-best
				AlignmentScore sco;
				Boolean mate1 = rd.mate < 2; // first iteration: self
				if(self > 0) mate1 = !mate1; // second iteration: opposite
				if(flags.partOfPair()) {
					sco = summ.bestUnchosenPScore(mate1);
				} else {
					sco = summ.bestUnchosenUScore();
				}
				if(sco.valid()) {
					secondBest[self] = sco.score();
				}

				// Third-best
				thirdBest[self] = mate1 ? prm.bestLtMinscMate1 : prm.bestLtMinscMate2;
				
				if(flags.partOfPair()) {
					if(summ.bestUnchosenPDist(mate1).valid()) {
						diffEd[self] = best[self].basesAligned() - summ.bestUnchosenPDist(mate1).basesAligned();
					}
				} else {
					if(summ.bestUnchosenUDist().valid()) {
						diffEd[self] = best[self].basesAligned() - summ.bestUnchosenUDist().basesAligned();
					}
				}
			}
			long diff[2] = {MN, MN};
			for(int self = 0; self < 2; self++) {
				long mx = max(secondBest[self], thirdBest[self]);
				if(best[self].score() > MN && mx > MN) {
					diff[self] = best[self].score() - mx;
				}
			}
			long best_conc = MN, diff_conc = MN;
			int diffEd_conc = ED_MAX;
			if(paired && summ.bestCScore().valid()) {
				best_conc = summ.bestCScore().score();
				if(summ.bestUnchosenCScore().valid()) {
					diff_conc = best_conc - summ.bestUnchosenCScore().score();
				}
				if(summ.bestUnchosenCDist().valid()) {
					diffEd_conc = summ.bestCDist().basesAligned() - summ.bestUnchosenCDist().basesAligned();
				}
			}
			o.append("ZT:Z:");
			// AS:i for current mate
			itoa10<long>((int)best[0].score(), buf);
			o.append(buf);
			o.append(",");
			// diff for current mate
			if(diff[0] > MN) {
				itoa10<long>((int)diff[0], buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
			o.append(",");
			// edit distance diff for current mate
			if(diffEd[0] != ED_MAX) {
				itoa10<long>((int)diffEd[0], buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
			o.append(",");
			// AS:i for other mate
			if(best[1].score() > MN) {
				itoa10<long>((int)best[1].score(), buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
			o.append(",");
			// diff for other mate
			if(diff[1] > MN) {
				itoa10<long>((int)diff[1], buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
			o.append(",");
			// Sum of AS:i for aligned pairs
			if(best_conc > MN) {
				itoa10<long>((int)best_conc, buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
			o.append(",");
			// Diff for aligned pairs
			if(diff_conc > MN) {
				itoa10<long>((int)diff_conc, buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
			o.append(",");
			// Edit distance diff for aligned pairs
			if(diffEd_conc != ED_MAX) {
				itoa10<long>((int)diffEd_conc, buf);
				o.append(buf);
			} else {
				o.append("NA");
			}
			// Flags related to seed hits, specific to this mate but not to the
			// strand aligned to
			int mate = (rd.mate < 2 ? 0 : 1);
			o.append(",");
			itoa10<long>((int)((prm.seedsPerNucMS[2 * mate] + prm.seedsPerNucMS[2 * mate + 1]) * 1000), buf);
			o.append(buf);
			o.append(",");
			itoa10<long>((int)((prm.seedPctUniqueMS[2 * mate] + prm.seedPctUniqueMS[2 * mate + 1]) * 1000), buf);
			o.append(buf);
			o.append(",");
			itoa10<long>((int)((prm.seedPctRepMS[2 * mate] + prm.seedPctRepMS[2 * mate + 1]) * 1000), buf);
			o.append(buf);
			o.append(",");
			itoa10<long>((int)((prm.seedHitAvgMS[2 * mate] + prm.seedHitAvgMS[2 * mate + 1]) + 0.5f), buf);
			o.append(buf);
			// Flags related to seed hits again, but specific both to this mate and
			// to the strand aligned to
			int fw = res.fw() ? 0 : 1;
			o.append(",");
			itoa10<long>((int)(prm.seedsPerNucMS[2 * mate + fw] * 1000), buf);
			o.append(buf);
			o.append(",");
			itoa10<long>((int)(prm.seedPctUniqueMS[2 * mate + fw] * 1000), buf);
			o.append(buf);
			o.append(",");
			itoa10<long>((int)(prm.seedPctRepMS[2 * mate + fw] * 1000), buf);
			o.append(buf);
			o.append(",");
			itoa10<long>((int)(prm.seedHitAvgMS[2 * mate + fw] + 0.5f), buf);
			o.append(buf);
		}
	}
	
	public Boolean omitSecondarySeqQuals() {
		return omitsec_;
	}
	
	public Boolean omitUnalignedReads() {
		return noUnal_;
	}
	
	public void printEmptyOptFlags(
			BTString o,               // output buffer
			Boolean first,                // first opt flag printed is first overall?
			Read rd,            // read
			AlnFlags flags,     // alignment flags
			AlnSetSumm summ,    // summary of alignments for this read
			SeedAlSumm ssm,     // seed alignment summary
			PerReadMetrics prm, // per-read metrics
			Scoring sc
			) {
		String buf;
		if(print_yn_) {
			// YN:i: Minimum valid score for this mate
			long mn = sc.scoreMin.f<long>(rd.length());
			itoa10<long>(mn, buf);
			WRITE_SEP();
			o.append("YN:i:");
			o.append(buf);
			// Yn:i: Perfect score for this mate
			long pe = sc.perfectScore(rd.length());
			itoa10<long>(pe, buf);
			WRITE_SEP();
			o.append("Yn:i:");
			o.append(buf);
		}
		if(print_zs_) {
			// ZS:i: Pseudo-random seed for read
			itoa10<double>(rd.seed, buf);
			WRITE_SEP();
			o.append("ZS:i:");
			o.append(buf);
		}
		if(print_yt_) {
			// YT:Z: String representing alignment type
			WRITE_SEP();
			flags.printYT(o);
		}
		if(print_yp_ && flags.partOfPair() && flags.canMax()) {
			// YP:i: Read was repetitive when aligned paired?
			WRITE_SEP();
			flags.printYP(o);
		}
		if(print_ym_ && flags.canMax() && (flags.isMixedMode() || !flags.partOfPair())) {
			// YM:i: Read was repetitive when aligned unpaired?
			WRITE_SEP();
			flags.printYM(o);
		}
		if(print_yf_ && flags.filtered()) {
			// YF:i: Why read was filtered out prior to alignment
			first = flags.printYF(o, first) && first;
		}
		if(!rgs_.empty()) {
			WRITE_SEP();
			o.append(rgs_);
		}
		if(print_xt_) {
			// XT:i: Timing
			WRITE_SEP();
			o.append("XT:i:");
			o.append(buf);
		}
		if(print_xd_) {
			// XD:i: Extend DPs
			WRITE_SEP();
			itoa10<long>(prm.nExDps, buf);
			o.append("XD:i:");
			o.append(buf);
			// Xd:i: Mate DPs
			WRITE_SEP();
			itoa10<long>(prm.nMateDps, buf);
			o.append("Xd:i:");
			o.append(buf);
		}
		if(print_xu_) {
			// XU:i: Extend ungapped tries
			WRITE_SEP();
			itoa10<long>(prm.nExUgs, buf);
			o.append("XU:i:");
			o.append(buf);
			// Xu:i: Mate ungapped tries
			WRITE_SEP();
			itoa10<long>(prm.nMateUgs, buf);
			o.append("Xu:i:");
			o.append(buf);
		}
		if(print_ye_) {
			// YE:i: Streak of failed DPs at end
			WRITE_SEP();
			itoa10<long>(prm.nDpFail, buf);
			o.append("YE:i:");
			o.append(buf);
			// Ye:i: Streak of failed ungaps at end
			WRITE_SEP();
			itoa10<long>(prm.nUgFail, buf);
			o.append("Ye:i:");
			o.append(buf);
		}
		if(print_yl_) {
			// YL:i: Longest streak of failed DPs
			WRITE_SEP();
			itoa10<long>(prm.nDpFailStreak, buf);
			o.append("YL:i:");
			o.append(buf);
			// Yl:i: Longest streak of failed ungaps
			WRITE_SEP();
			itoa10<long>(prm.nUgFailStreak, buf);
			o.append("Yl:i:");
			o.append(buf);
		}
		if(print_yu_) {
			// YU:i: Index of last succesful DP
			WRITE_SEP();
			itoa10<long>(prm.nDpLastSucc, buf);
			o.append("YU:i:");
			o.append(buf);
			// Yu:i: Index of last succesful DP
			WRITE_SEP();
			itoa10<long>(prm.nUgLastSucc, buf);
			o.append("Yu:i:");
			o.append(buf);
		}
		if(print_xp_) {
			// XP:Z: String describing seed hits
			WRITE_SEP();
			o.append("XP:B:I,");
			itoa10<long>(prm.nSeedElts, buf);
			o.append(buf);
			o.append(',');
			itoa10<long>(prm.nSeedEltsFw, buf);
			o.append(buf);
			o.append(',');
			itoa10<long>(prm.nSeedEltsRc, buf);
			o.append(buf);
			o.append(',');
			itoa10<long>(prm.seedMean, buf);
			o.append(buf);
			o.append(',');
			itoa10<long>(prm.seedMedian, buf);
			o.append(buf);
		}
		if(print_yr_) {
			// YR:i: Redundant seed hits
			WRITE_SEP();
			itoa10<long>(prm.nRedundants, buf);
			o.append("YR:i:");
			o.append(buf);
		}
		if(print_zb_) {
			// ZB:i: Ftab ops for seed alignment
			WRITE_SEP();
			itoa10<long>(prm.nFtabs, buf);
			o.append("ZB:i:");
			o.append(buf);
		}
		if(print_zr_) {
			// ZR:Z: Redundant path skips in seed alignment
			WRITE_SEP();
			o.append("ZR:Z:");
			itoa10<long>(prm.nRedSkip, buf); o.append(buf);
			o.append(',');
			itoa10<long>(prm.nRedFail, buf); o.append(buf);
			o.append(',');
			itoa10<long>(prm.nRedIns, buf); o.append(buf);
		}
		if(print_zf_) {
			// ZF:i: FM Index ops for seed alignment
			WRITE_SEP();
			itoa10<long>(prm.nSdFmops, buf);
			o.append("ZF:i:");
			o.append(buf);
			// Zf:i: FM Index ops for offset resolution
			WRITE_SEP();
			itoa10<long>(prm.nExFmops, buf);
			o.append("Zf:i:");
			o.append(buf);
		}
		if(print_zm_) {
			// ZM:Z: Print FM index op string for best-first search
			WRITE_SEP();
			o.append("ZM:Z:");
			prm.fmString.print(o, buf);
		}
		if(print_zi_) {
			// ZI:i: Seed extend loop iterations
			WRITE_SEP();
			itoa10<long>(prm.nExIters, buf);
			o.append("ZI:i:");
			o.append(buf);
		}
		if(print_xr_) {
			// Original read string
			o.append("\n");
			printOptFieldNewlineEscapedZ(o, rd.readOrigBuf);
		}
	}
}
